<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>multiformats.multiaddr API documentation</title>
<meta name="description" content="Implementation of the [multiaddr spec](https://github.com/multiformats/multiaddr) …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.hljs-meta{user-select:none;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;pointer-events:none}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>multiformats.multiaddr</code></h1>
</header>
<section id="section-intro">
<p>Implementation of the <a href="https://github.com/multiformats/multiaddr">multiaddr spec</a>.</p>
<p>Core functionality is provided by the <code><a title="multiformats.multiaddr.Proto" href="#multiformats.multiaddr.Proto">Proto</a></code> class:</p>
<pre><code class="language-py">&gt;&gt;&gt; from multiformats import Proto
&gt;&gt;&gt; ip4 = Proto(&quot;ip4&quot;)
&gt;&gt;&gt; ip4
Proto(&quot;ip4&quot;)
&gt;&gt;&gt; str(ip4)
'/ip4'
&gt;&gt;&gt; ip4.codec
Multicodec(name='ip4', tag='multiaddr', code='0x04',
           status='permanent', description='')
</code></pre>
<p>Slash notation is used to attach address values to protocols:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = ip4/&quot;192.168.1.1&quot;
&gt;&gt;&gt; a
Addr('ip4', '192.168.1.1')
&gt;&gt;&gt; str(a)
'/ip4/192.168.1.1'
&gt;&gt;&gt; bytes(a)
b'\x04\xc0\xa8\x01\x01'
</code></pre>
<p>Address values can be specified as strings, integers, or <code>bytes</code>-like objects:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4/&quot;192.168.1.1&quot;
Addr('ip4', '192.168.1.1')
&gt;&gt;&gt; ip4/b'\xc0\xa8\x01\x01' # ip4/bytes([192, 168, 1, 1])
Addr('ip4', '192.168.1.1')
&gt;&gt;&gt; udp = Proto(&quot;udp&quot;)
&gt;&gt;&gt; udp/9090 # udp/&quot;9090&quot;
Addr('udp', '9090')
</code></pre>
<p>Slash notation is also used to encapsulate multiple protocol/address segments into a <a href="https://multiformats.io/multiaddr/">multiaddr</a>:</p>
<pre><code class="language-py">&gt;&gt;&gt; quic = Proto(&quot;quic&quot;)
&gt;&gt;&gt; ma = ip4/&quot;127.0.0.1&quot;/udp/9090/quic
&gt;&gt;&gt; ma
Multiaddr(Addr('ip4', '127.0.0.1'), Addr('udp', '9090'), Proto('quic'))
&gt;&gt;&gt; str(ma)
'/ip4/127.0.0.1/udp/9090/quic'
</code></pre>
<p>Bytes for multiaddrs are computed according to the <a href="https://multiformats.io/multiaddr/"><code>(TLV)+</code> multiaddr encoding</a>:</p>
<pre><code class="language-py">&gt;&gt;&gt; bytes(ip4/&quot;127.0.0.1&quot;).hex()
'047f000001'
&gt;&gt;&gt; bytes(udp/9090).hex()
          '91022382'
&gt;&gt;&gt; bytes(quic).hex()
                  'cc03'
&gt;&gt;&gt; bytes(ma).hex()
'047f00000191022382cc03'
</code></pre>
<p>The <code><a title="multiformats.multiaddr.parse" href="#multiformats.multiaddr.parse">parse()</a></code> and <code><a title="multiformats.multiaddr.decode" href="#multiformats.multiaddr.decode">decode()</a></code> functions create multiaddrs from their human-readable strings and encoded bytes respectively:</p>
<pre><code class="language-py">    &gt;&gt;&gt; from multiformats import multiaddr
    &gt;&gt;&gt; s = '/ip4/127.0.0.1/udp/9090/quic'
    &gt;&gt;&gt; multiaddr.parse(s)
    Multiaddr(Addr('ip4', '127.0.0.1'), Addr('udp', '9090'), Proto('quic'))
    &gt;&gt;&gt; b = bytes.fromhex('047f00000191022382cc03')
    &gt;&gt;&gt; multiaddr.decode(b)
    Multiaddr(Addr('ip4', '127.0.0.1'), Addr('udp', '9090'), Proto('quic'))
</code></pre>
<p>For uniformity of API, the same functionality as the <code><a title="multiformats.multiaddr.Proto" href="#multiformats.multiaddr.Proto">Proto</a></code> class is provided by the <code><a title="multiformats.multiaddr.proto" href="#multiformats.multiaddr.proto">proto()</a></code> function:</p>
<pre><code class="language-py">&gt;&gt;&gt; from multiformats import multiaddr
&gt;&gt;&gt; ip4 = multiaddr.proto(&quot;ip4&quot;)
&gt;&gt;&gt; ip4
Proto(&quot;ip4&quot;)
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    Implementation of the [multiaddr spec](https://github.com/multiformats/multiaddr).

    Core functionality is provided by the `Proto` class:

    ```py
    &gt;&gt;&gt; from multiformats import Proto
    &gt;&gt;&gt; ip4 = Proto(&#34;ip4&#34;)
    &gt;&gt;&gt; ip4
    Proto(&#34;ip4&#34;)
    &gt;&gt;&gt; str(ip4)
    &#39;/ip4&#39;
    &gt;&gt;&gt; ip4.codec
    Multicodec(name=&#39;ip4&#39;, tag=&#39;multiaddr&#39;, code=&#39;0x04&#39;,
               status=&#39;permanent&#39;, description=&#39;&#39;)
    ```

    Slash notation is used to attach address values to protocols:

    ```py
    &gt;&gt;&gt; a = ip4/&#34;192.168.1.1&#34;
    &gt;&gt;&gt; a
    Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
    &gt;&gt;&gt; str(a)
    &#39;/ip4/192.168.1.1&#39;
    &gt;&gt;&gt; bytes(a)
    b&#39;\\x04\\xc0\\xa8\\x01\\x01&#39;
    ```

    Address values can be specified as strings, integers, or `bytes`-like objects:

    ```py
    &gt;&gt;&gt; ip4/&#34;192.168.1.1&#34;
    Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
    &gt;&gt;&gt; ip4/b&#39;\\xc0\\xa8\\x01\\x01&#39; # ip4/bytes([192, 168, 1, 1])
    Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
    &gt;&gt;&gt; udp = Proto(&#34;udp&#34;)
    &gt;&gt;&gt; udp/9090 # udp/&#34;9090&#34;
    Addr(&#39;udp&#39;, &#39;9090&#39;)
    ```

    Slash notation is also used to encapsulate multiple protocol/address segments into a [multiaddr](https://multiformats.io/multiaddr/):

    ```py
    &gt;&gt;&gt; quic = Proto(&#34;quic&#34;)
    &gt;&gt;&gt; ma = ip4/&#34;127.0.0.1&#34;/udp/9090/quic
    &gt;&gt;&gt; ma
    Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Addr(&#39;udp&#39;, &#39;9090&#39;), Proto(&#39;quic&#39;))
    &gt;&gt;&gt; str(ma)
    &#39;/ip4/127.0.0.1/udp/9090/quic&#39;
    ```

    Bytes for multiaddrs are computed according to the [`(TLV)+` multiaddr encoding](https://multiformats.io/multiaddr/):

    ```py
    &gt;&gt;&gt; bytes(ip4/&#34;127.0.0.1&#34;).hex()
    &#39;047f000001&#39;
    &gt;&gt;&gt; bytes(udp/9090).hex()
              &#39;91022382&#39;
    &gt;&gt;&gt; bytes(quic).hex()
                      &#39;cc03&#39;
    &gt;&gt;&gt; bytes(ma).hex()
    &#39;047f00000191022382cc03&#39;
    ```

    The `parse` and `decode` functions create multiaddrs from their human-readable strings and encoded bytes respectively:

    ```py
        &gt;&gt;&gt; from multiformats import multiaddr
        &gt;&gt;&gt; s = &#39;/ip4/127.0.0.1/udp/9090/quic&#39;
        &gt;&gt;&gt; multiaddr.parse(s)
        Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Addr(&#39;udp&#39;, &#39;9090&#39;), Proto(&#39;quic&#39;))
        &gt;&gt;&gt; b = bytes.fromhex(&#39;047f00000191022382cc03&#39;)
        &gt;&gt;&gt; multiaddr.decode(b)
        Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Addr(&#39;udp&#39;, &#39;9090&#39;), Proto(&#39;quic&#39;))
    ```

    For uniformity of API, the same functionality as the `Proto` class is provided by the `proto` function:

    ```py
    &gt;&gt;&gt; from multiformats import multiaddr
    &gt;&gt;&gt; ip4 = multiaddr.proto(&#34;ip4&#34;)
    &gt;&gt;&gt; ip4
    Proto(&#34;ip4&#34;)
    ```

&#34;&#34;&#34;

from ipaddress import AddressValueError
from itertools import islice, chain
from typing import Any, cast, ClassVar, Dict, Iterator, List, Optional, overload, Sequence, Tuple, Type, Union
from weakref import WeakValueDictionary
import sys
from typing_validation import validate

from multiformats import varint, multicodec
from multiformats.multicodec import Multicodec
from multiformats.varint import BytesLike, byteslike

from . import raw
from .raw import RawEncoder, RawDecoder, ProtoImpl, _validate_size

class Proto:
    &#34;&#34;&#34;
        Container class for a single protocol segment of a [multiaddr](https://multiformats.io/multiaddr/).

        ```py
        &gt;&gt;&gt; ip4 = Proto(&#34;ip4&#34;)
        &gt;&gt;&gt; ip4
        Proto(&#34;ip4&#34;)
        &gt;&gt;&gt; str(ip4)
        &#39;/ip4&#39;
        ```

        For protocols that don&#39;t require an address value, bytes are computed as the varint encoding of protocl code:

        ```py
        &gt;&gt;&gt; quic = Proto(&#39;quic&#39;)
        &gt;&gt;&gt; quic.code
        460
        &gt;&gt;&gt; varint.encode(quic.code).hex()
        &#39;cc03&#39;
        &gt;&gt;&gt; bytes(quic).hex()
        &#39;cc03&#39;
        ```
    &#34;&#34;&#34;

    # WeakValueDictionary[str, &#34;Proto&#34;]
    _cache: ClassVar[WeakValueDictionary] = WeakValueDictionary() # type: ignore

    _codec: Multicodec
    _implementation: ProtoImpl

    __slots__ = (&#34;__weakref__&#34;, &#34;_codec&#34;, &#34;_implementation&#34;)

    def __new__(cls, codec: Union[str, int, Multicodec]) -&gt; &#34;Proto&#34;:
        # check that the codec exists:
        if isinstance(codec, str):
            codec = multicodec.get(codec)
        elif isinstance(codec, int):
            codec = multicodec.get(code=codec)
        else:
            validate(codec, Multicodec)
            existing_codec = multicodec.get(codec.name)
            if existing_codec != codec:
                raise ValueError(f&#34;Multicodec named {repr(codec.name)} exists, but is not the one given.&#34;)
            codec = existing_codec
        # check that the codec is a multiaddr multicodec:
        if codec.tag != &#34;multiaddr&#34;:
            raise ValueError(f&#34;Multicodec named {repr(codec.name)} exists, but is not a multiaddr.&#34;)
        implementation: ProtoImpl = raw.get(codec.name)
        _cache = Proto._cache
        if codec.name in _cache:
            # if a proto instance with this name is already registered
            instance: Proto = _cache[codec.name]
            if instance._codec == codec and instance._implementation == implementation:
                # nothing changed, can use the existing instance
                return instance
            # otherwise remove the existing instance
            del _cache[codec.name]
        # create a fresh instance, register it and return it
        instance = super().__new__(cls)
        instance._codec = codec
        instance._implementation = implementation
        _cache[codec.name] = instance
        return instance

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
            Protocol name.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.name
            &#39;ip4&#39;
            ```
        &#34;&#34;&#34;
        return self.codec.name

    @property
    def code(self) -&gt; int:
        &#34;&#34;&#34;
            Protocol code.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.code
            4
            # 4 = 0x04
            ```
        &#34;&#34;&#34;
        return self.codec.code

    @property
    def codec(self) -&gt; Multicodec:
        &#34;&#34;&#34;
            The multicodec for this protocol.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.codec
            Multicodec(name=&#39;ip4&#39;, tag=&#39;multiaddr&#39;, code=&#39;0x04&#39;,
                       status=&#39;permanent&#39;, description=&#39;&#39;)
            ```
        &#34;&#34;&#34;
        return self._codec

    @property
    def implementation(self) -&gt; ProtoImpl:
        &#34;&#34;&#34;
            The implementation for this protocol, as a triple of
            raw encoder, raw decoder and address size.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.implementation
            (
             &lt;function ip4_encoder at 0x000002B4C9956310&gt;,
             &lt;function ip4_decoder at 0x000002B4C99563A0&gt;,
             4
            )
            ```
        &#34;&#34;&#34;
        return self._implementation

    @property
    def raw_encoder(self) -&gt; Optional[RawEncoder]:
        &#34;&#34;&#34;
            The raw encoder for this protocol.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.raw_encoder
            &lt;function ip4_encoder at 0x000002B4C9956310&gt;
            ```
        &#34;&#34;&#34;
        return self.implementation[0]

    @property
    def raw_decoder(self) -&gt; Optional[RawDecoder]:
        &#34;&#34;&#34;
            The raw decoder for this protocol.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.raw_decoder
            &lt;function ip4_decoder at 0x000002B4C99563A0&gt;
            ```
        &#34;&#34;&#34;
        return self.implementation[1]

    @property
    def addr_size(self) -&gt; Optional[int]:
        &#34;&#34;&#34;
            The address size (in bytes) for this protocol:

            - for protocols with no address, `addr_size` is 0
            - for protocols with addresses of variable binary size, `addr_size` is `None`
            - for all other protocols, size is a positive `int`

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.addr_size
            4
            ```
        &#34;&#34;&#34;
        return self.implementation[2]

    @property
    def admits_addr(self) -&gt; bool:
        &#34;&#34;&#34;
            Whether this protocol admits an address.

            ```py
            &gt;&gt;&gt; ip4.admits_addr
            True
            ```
        &#34;&#34;&#34;
        return self.addr_size != 0

    def is_addr_valid(self, addr_value: Union[str, BytesLike]) -&gt; bool:
        &#34;&#34;&#34;
            Validates an address value.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.is_addr_valid(&#34;192.168.1.1&#34;)
            True
            &gt;&gt;&gt; ip4.is_addr_valid(bytes([192, 168, 1, 1]))
            True
            ```

            The same result can be obtained with container syntax:

            ```py
            &gt;&gt;&gt; &#34;192.168.1.1&#34; in ip4
            True
            &gt;&gt;&gt; bytes([192, 168, 1, 1]) in ip4
            True
            ```
        &#34;&#34;&#34;
        try:
            self.validate(addr_value)
            return True
        except AddressValueError:
            return False

    def validate(self, addr_value: Union[str, BytesLike]) -&gt; Tuple[str, bytes]:
        &#34;&#34;&#34;
            Raises `ValueError` if `not self.is_valid(addr_value)`.
            If successful, returns a pair of the string and bytes representations of the address value.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.validate(&#34;192.168.1.1&#34;)
            (&#39;192.168.1.1&#39;, b&#39;\\xc0\\xa8\\x01\\x01&#39;)
            &gt;&gt;&gt; ip4.validate(&#34;192.168&#34;)
            ipaddress.AddressValueError: Expected 4 octets in &#39;192.168&#39;
            ```
        &#34;&#34;&#34;
        raw_encoder, raw_decoder, addr_size = self.implementation
        if addr_size == 0:
            raise AddressValueError(f&#34;Protocol admits no address value, but {repr(addr_value)} was passed.&#34;)
        if isinstance(addr_value, byteslike):
            assert raw_decoder is not None
            addr_value_str = raw_decoder(addr_value) # raises AddressValueError if addr_value is invalid
            if not isinstance(addr_value, bytes):
                addr_value = bytes(addr_value)
            return addr_value_str, addr_value
        validate(addr_value, str)
        assert raw_encoder is not None
        addr_value_bytes = raw_encoder(addr_value) # raises AddressValueError if addr_value is invalid
        return addr_value, addr_value_bytes

    def addr(self, value: Union[str, BytesLike]) -&gt; &#34;Addr&#34;:
        &#34;&#34;&#34;
            Returns an address for this protocol.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.addr(&#34;192.168.1.1&#34;)
            Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            &gt;&gt;&gt; ip4.addr(bytes([192, 168, 1, 1]))
            Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            ```

            The same address can be obtained with slash syntax:

            ```py
            &gt;&gt;&gt; ip4/&#34;192.168.1.256&#34;
            Addr(&#39;ip4&#39;, &#39;192.168.1.256&#39;)
            &gt;&gt;&gt; ip4/b&#39;\\xc0\\xa8\\x01\\x01&#39;
            Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            ```
        &#34;&#34;&#34;
        return Addr(self, value)

    def __contains__(self, value: Union[str, BytesLike]) -&gt; bool:
        return self.is_addr_valid(value)

    @overload
    def __truediv__(self, value: Union[&#34;Proto&#34;, &#34;Addr&#34;, &#34;Multiaddr&#34;]) -&gt; &#34;Multiaddr&#34;:
        ...

    @overload
    def __truediv__(self, value: Union[int, str, BytesLike]) -&gt; &#34;Addr&#34;:
        ...

    def __truediv__(self, value: Union[int, str, BytesLike, &#34;Proto&#34;, &#34;Addr&#34;, &#34;Multiaddr&#34;]) -&gt; Union[&#34;Addr&#34;, &#34;Multiaddr&#34;]:
        if isinstance(value, int):
            value = str(value)
        if isinstance(value, (str,)+byteslike):
            return self.addr(value)
        if isinstance(value, (Addr, Proto)):
            return Multiaddr(self, value)
        if isinstance(value, Multiaddr):
            return Multiaddr(self, *value)
        return NotImplemented

    def __str__(self) -&gt; str:
        return f&#34;/{self.name}&#34;

    def __bytes__(self) -&gt; bytes:
        if self.addr_size != 0:
            raise ValueError(&#34;Missing address value for protocol, cannot compute bytes.&#34;)
        return varint.encode(self.code)

    def __repr__(self) -&gt; str:
        return f&#34;Proto({repr(self.name)})&#34;

    @property
    def _as_tuple(self) -&gt; Tuple[Type[&#34;Proto&#34;], Multicodec]:
        return (Proto, self.codec)

    def __hash__(self) -&gt; int:
        return hash(self._as_tuple)

    def __eq__(self, other: Any) -&gt; bool:
        if self is other:
            return True
        if not isinstance(other, Proto):
            return NotImplemented
        return self._as_tuple == other._as_tuple

class Addr:
    &#34;&#34;&#34;
        Container class for a single protocol address in a [multiaddr](https://multiformats.io/multiaddr/).

        ```py
        &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        &gt;&gt;&gt; a
        Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        &gt;&gt;&gt; str(a)
        &#39;/ip4/192.168.1.1&#39;
        ```

        The slash notation provides a more literate way to construct protocol addresses:

        ```py
        &gt;&gt;&gt; a = ip4/&#34;192.168.1.1&#34;
        &gt;&gt;&gt; a
        Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        ```

        Bytes for protocol addresses are computed according to the TLV [multiaddr format](https://multiformats.io/multiaddr/):

        ```py
        &gt;&gt;&gt; bytes(ip4/&#34;127.0.0.1&#34;).hex()
        &#39;047f000001&#39;
        &gt;&gt;&gt; varint.encode(ip4.code).hex()
        &#39;04&#39;
        &gt;&gt;&gt; bytes([127, 0, 0, 1]).hex()
          &#39;7f000001&#39;
        ```
    &#34;&#34;&#34;

    _proto: Proto
    _value: str
    _value_bytes: bytes

    __slots__ = (&#34;__weakref__&#34;, &#34;_proto&#34;, &#34;_value&#34;, &#34;_value_bytes&#34;)

    def __new__(cls, proto: Union[str, int, Multicodec, Proto], value: Union[str, BytesLike]) -&gt; &#34;Addr&#34;:
        if not isinstance(proto, Proto):
            proto = Proto(proto)
        value, value_bytes = proto.validate(value)
        instance: Addr = super().__new__(cls)
        instance._proto = proto
        instance._value = value
        instance._value_bytes = value_bytes
        return instance

    @property
    def proto(self) -&gt; Proto:
        &#34;&#34;&#34;
            The address protocol.

            Example usage:

            ```py
            &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            &gt;&gt;&gt; a.proto
            Proto(&#39;ip4&#39;)
            ```
        &#34;&#34;&#34;
        return self._proto

    @property
    def value(self) -&gt; str:
        &#34;&#34;&#34;
            The address value, as a string.

            Example usage:

            ```py
            &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            &gt;&gt;&gt; a.value
            &#39;192.168.1.1&#39;
            ```
        &#34;&#34;&#34;
        return self._value

    @property
    def value_bytes(self) -&gt; bytes:
        &#34;&#34;&#34;
            The address value, as bytes.

            Example usage:

            ```py
            &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            &gt;&gt;&gt; a.value_bytes
            b&#39;\\xc0\\xa8\\x01\\x01&#39;
            &gt;&gt;&gt; list(a.value_bytes)
            [192, 168, 1, 1]
            ```
        &#34;&#34;&#34;
        return self._value_bytes

    def __truediv__(self, other: Union[Proto, &#34;Addr&#34;, &#34;Multiaddr&#34;]) -&gt; &#34;Multiaddr&#34;:
        if isinstance(other, (Addr, Proto)):
            return Multiaddr(self, other)
        if isinstance(other, Multiaddr):
            return Multiaddr(self, *other)
        return NotImplemented

    def __str__(self) -&gt; str:
        return f&#34;{str(self.proto)}/{self.value}&#34;

    def __bytes__(self) -&gt; bytes:
        chunks: List[bytes] = []
        proto = self.proto
        value_bytes = self.value_bytes
        chunks.append(varint.encode(proto.code))
        if proto.addr_size is None:
            assert value_bytes is not None
            chunks.append(varint.encode(len(value_bytes)))
        chunks.append(value_bytes)
        return bytes(chain.from_iterable(chunks))

    def __repr__(self) -&gt; str:
        return f&#34;Addr({repr(self.proto.name)}, {repr(self.value)})&#34;

    @property
    def _as_tuple(self) -&gt; Tuple[Type[&#34;Addr&#34;], Proto, Optional[str]]:
        return (Addr, self.proto, self.value)

    def __hash__(self) -&gt; int:
        return hash(self._as_tuple)

    def __eq__(self, other: Any) -&gt; bool:
        if self is other:
            return True
        if not isinstance(other, Addr):
            return NotImplemented
        return self._as_tuple == other._as_tuple


class Multiaddr(Sequence[Union[Addr, Proto]]):
    &#34;&#34;&#34;
        Container class for a [multiaddr](https://multiformats.io/multiaddr/).

        Example usage:

        ```py
        &gt;&gt;&gt; ip4 = Proto(&#34;ip4&#34;)
        &gt;&gt;&gt; udp = Proto(&#34;udp&#34;)
        &gt;&gt;&gt; quic = Proto(&#34;quic&#34;)
        &gt;&gt;&gt; ma = ip4/&#34;127.0.0.1&#34;/udp/9090/quic
        &gt;&gt;&gt; ma
        Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Addr(&#39;udp&#39;, &#39;9090&#39;), Proto(&#39;quic&#39;))
        &gt;&gt;&gt; str(ma)
        &#39;/ip4/127.0.0.1/udp/9090/quic&#39;
        ```

        Bytes for multiaddrs are computed according to the (TLV)+ [multiaddr format](https://multiformats.io/multiaddr/):

        ```py
        &gt;&gt;&gt; bytes(ip4/&#34;127.0.0.1&#34;).hex()
        &#39;047f000001&#39;
        &gt;&gt;&gt; bytes(udp/9090).hex()
                  &#39;91022382&#39;
        &gt;&gt;&gt; bytes(quic).hex()
                          &#39;cc03&#39;
        &gt;&gt;&gt; bytes(ma).hex()
        &#39;047f00000191022382cc03&#39;
        ```
    &#34;&#34;&#34;

    _addrs: Tuple[Union[Addr, Proto], ...]
    _proto_map: Dict[Proto, int]
    _is_incomplete: bool

    __slots__ = (&#34;__weakref__&#34;, &#34;_addrs&#34;, &#34;_proto_map&#34;, &#34;_is_incomplete&#34;)

    def __new__(cls, *addrs: Union[Addr, Proto]) -&gt; &#34;Multiaddr&#34;:
        l = len(addrs)
        is_incomplete = False
        proto_map: Dict[Proto, int] = {}
        for idx, addr in enumerate(addrs):
            if isinstance(addr, Proto):
                proto = addr
                if proto.addr_size != 0:
                    if idx == l-1:
                        is_incomplete = True
                    else:
                        raise ValueError(f&#34;Protocol {repr(proto.name)} expects an address, but is followed by another protocol instead.&#34;)
            else:
                validate(addr, Addr)
                proto = addr.proto
            if proto in proto_map:
                raise ValueError(f&#34;Protocol {repr(proto.name)} appears twice in multiaddr.&#34;)
            proto_map[proto] = idx
        instance: Multiaddr = super().__new__(cls)
        instance._addrs = addrs
        instance._proto_map = proto_map
        instance._is_incomplete = is_incomplete
        return instance

    @property
    def is_incomplete(self) -&gt; bool:
        &#34;&#34;&#34;
            Whether this multiaddress is incomplete, i.e. it still requires an address for
            the last protocol in the sequence.

            ```py
            &gt;&gt;&gt; ma = ip4/&#34;127.0.0.1&#34;/udp
            &gt;&gt;&gt; ma.is_incomplete
            True
            &gt;&gt;&gt; str(ma)
            &#39;/ip4/127.0.0.1/udp&#39;
            &gt;&gt;&gt; ma2 = ma/9090
            &gt;&gt;&gt; str(ma2)
            &#39;/ip4/127.0.0.1/udp/9090&#39;
            &gt;&gt;&gt; ma2.is_incomplete
            False
            ```

            Incomplete multiaddrs don&#39;t admit a byte representation:

            ```py
            &gt;&gt;&gt; bytes(ma)
            ValueError: Missing address value for last protocol, cannot compute bytes.
            &gt;&gt;&gt; bytes(ma2).hex()
            &#39;047f00000191022382&#39;
            ```
        &#34;&#34;&#34;
        return self._is_incomplete

    def index(self, value: Union[Addr, Proto], start: int = 0, stop: Optional[int] = None) -&gt; int:
        &#34;&#34;&#34;
            Returns the unique index at which a protocol/address appears in the multiaddress:

            ```py
            &gt;&gt;&gt; ma = ip4/&#34;127.0.0.1&#34;/udp/9090/quic
            &gt;&gt;&gt; str(ma)
            &#39;/ip4/127.0.0.1/udp/9090/quic&#39;
            &gt;&gt;&gt; udp in ma
            True
            &gt;&gt;&gt; ma.index(udp)
            1
            &gt;&gt;&gt; ma[ma.index(udp)]
            Addr(&#39;udp&#39;, &#39;9090&#39;)
            &gt;&gt;&gt; ip4/&#34;127.0.0.1&#34; in ma
            True
            &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.1&#34; in ma)
            0
            ```

            This method raises `ValueError` if the protocol/address does not appear:

            ```py
            &gt;&gt;&gt; ip6 = Proto(&#34;ip6&#34;)
            &gt;&gt;&gt; ip6 in ma
            False
            &gt;&gt;&gt; ma.index(ip6)
            ValueError: Protocol &#39;ip6&#39; does not appear in multiaddr /ip4/127.0.0.1/udp/9090/quic
            &gt;&gt;&gt; ip4/&#34;127.0.0.2&#34; in ma
            False
            &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.2&#34;)
            ValueError: Address Addr(&#39;ip4&#39;, &#39;127.0.0.2&#39;) does not appear in multiaddr /ip4/127.0.0.1/udp/9090/quic
            ```

            The optional `start` and `stop` arguments can be used to specify a range of indices
            within which to search for the protocol/address.

            ```py
            &gt;&gt;&gt; ip4/&#34;127.0.0.1&#34; in ma
            True
            &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.1&#34;)
            0
            &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.1&#34;, start=1)
            ValueError: Address Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;) does not appear in sub-multiaddr /udp/9090/quic of multiaddr /ip4/127.0.0.1/udp/9090/quic
            ```
        &#34;&#34;&#34;
        validate(start, int)
        if stop is None:
            stop = len(self)
        validate(stop, int)
        if isinstance(value, Proto):
            proto = value
        else:
            validate(value, Addr)
            proto = value.proto
        if proto not in self._proto_map:
            raise ValueError(f&#34;Protocol {repr(proto.name)} does not appear in multiaddr {str(self)}&#34;)
        idx = self._proto_map[proto]
        if isinstance(value, Addr):
            if self[idx] != value:
                raise ValueError(f&#34;Address {repr(value)} does not appear in multiaddr {str(self)}&#34;)
            if not start &lt;= idx &lt; stop:
                raise ValueError(f&#34;Address {repr(value)} does not appear in sub-multiaddr {str(self[start:stop])} &#34;
                                 f&#34;of multiaddr {str(self)}&#34;)
        return idx

    def __contains__(self, value: Any) -&gt; bool:
        if isinstance(value, (Addr, Proto)):
            try:
                self.index(value)
                return True
            except ValueError:
                return False
        return False

    def __len__(self) -&gt; int:
        return len(self._addrs)

    def __iter__(self) -&gt; Iterator[Union[Addr, Proto]]:
        return iter(self._addrs)

    @overload
    def __getitem__(self, idx: int) -&gt; Union[Addr, Proto]:
        ...

    @overload
    def __getitem__(self, idx: slice) -&gt; &#34;Multiaddr&#34;:
        ...

    def __getitem__(self, idx: Union[int, slice]) -&gt; Union[Addr, Proto, &#34;Multiaddr&#34;]:
        if isinstance(idx, int):
            return self._addrs[idx]
        validate(idx, slice)
        return Multiaddr(*self._addrs[idx])

    def __truediv__(self, other: Union[int, str, BytesLike, Addr, Proto, &#34;Multiaddr&#34;]) -&gt; &#34;Multiaddr&#34;:
        if isinstance(other, (int, str,)+byteslike):
            if not self.is_incomplete:
                raise ValueError(&#34;Unexpected address value. Expected Proto, Addr or Multiaddr.&#34;)
            addrs = list(self)
            tail_proto = addrs[-1]
            assert isinstance(tail_proto, Proto)
            return Multiaddr(*islice(addrs, 0, len(addrs)-1), tail_proto/other)
        if isinstance(other, (Addr, Proto)):
            if self.is_incomplete:
                raise ValueError(&#34;Expected address value (string or binary).&#34;)
            return Multiaddr(*self, other)
        if isinstance(other, Multiaddr):
            if self.is_incomplete:
                raise ValueError(&#34;Expected address value (string or binary).&#34;)
            return Multiaddr(*self, *other)
        return NotImplemented

    def __str__(self) -&gt; str:
        return &#34;&#34;.join(str(a) for a in self)

    def __bytes__(self) -&gt; bytes:
        if self.is_incomplete:
            raise ValueError(&#34;Missing address value for last protocol, cannot compute bytes.&#34;)
        return bytes(chain.from_iterable(bytes(addr) for addr in self))

    def __repr__(self) -&gt; str:
        return f&#34;Multiaddr({&#39;, &#39;.join(repr(a) for a in self)})&#34;

    @property
    def _as_tuple(self) -&gt; Tuple[Type[&#34;Multiaddr&#34;], Tuple[Union[Addr, Proto], ...]]:
        return (Multiaddr, self._addrs)

    def __hash__(self) -&gt; int:
        return hash(self._as_tuple)

    def __eq__(self, other: Any) -&gt; bool:
        if self is other:
            return True
        if not isinstance(other, Multiaddr):
            return NotImplemented
        return self._as_tuple == other._as_tuple


def proto(codec: Union[str, int, Multicodec]) -&gt; Proto:
    &#34;&#34;&#34;
        Convenience function to construct a `Proto` instance.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4 = multiaddr.proto(&#34;ip4&#34;)
        &gt;&gt;&gt; ip4
        Proto(&#34;ip4&#34;)
        ```
    &#34;&#34;&#34;
    return Proto(codec)


def parse(multiaddr_str: str, allow_incomplete: bool = False) -&gt; Multiaddr:
    &#34;&#34;&#34;
        Parses a multiaddr from its human-readable string representation.

        Example usage:

        ```py
        &gt;&gt;&gt; s = &#39;/ip4/127.0.0.1/udp/9090/quic&#39;
        &gt;&gt;&gt; multiaddr.parse(s)
        Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Addr(&#39;udp&#39;, &#39;9090&#39;), Proto(&#39;quic&#39;))
        ```

        Example usage with incomplete multiaddr:

        ```py
        &gt;&gt;&gt; s = &#39;/ip4/127.0.0.1/udp&#39;
        &gt;&gt;&gt; multiaddr.parse(s)
        ValueError: Decoded multiaddr is incomplete: /ip4/127.0.0.1/udp
        &gt;&gt;&gt; multiaddr.parse(s, allow_incomplete=True)
        Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Proto(&#39;udp&#39;))
        ```
    &#34;&#34;&#34;
    validate(multiaddr_str, str)
    validate(allow_incomplete, bool)
    tokens = multiaddr_str.split(&#34;/&#34;)
    proto: Optional[Proto] = None
    segments: List[Union[Addr, Proto]] = []
    for token in islice(tokens, 1, None):
        if proto is None:
            proto = Proto(token)
            if not proto.admits_addr:
                segments.append(proto)
                proto = None
        else:
            segments.append(proto/token)
            proto = None
    if proto is not None:
        segments.append(proto)
    ma = Multiaddr(*segments)
    if ma.is_incomplete and not allow_incomplete:
        raise ValueError(f&#34;Decoded multiaddr is incomplete: {str(ma)}&#34;)
    return ma


def decode(multiaddr_bytes: BytesLike) -&gt; Multiaddr:
    &#34;&#34;&#34;
        Decodes a multiaddr from its `(TLV)+` binary encoding.

        Example usage:

        ```py
        &gt;&gt;&gt; b = bytes.fromhex(&#39;047f00000191022382cc03&#39;)
        &gt;&gt;&gt; multiaddr.decode(b)
        Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Addr(&#39;udp&#39;, &#39;9090&#39;), Proto(&#39;quic&#39;))
        ```
    &#34;&#34;&#34;
    validate(multiaddr_bytes, BytesLike)
    b = memoryview(multiaddr_bytes)
    proto: Optional[Proto] = None
    segments: List[Union[Addr, Proto]] = []
    while len(b) &gt; 0:
        if proto is None:
            code, _, b = varint.decode_raw(b)
            proto = Proto(code)
            if not proto.admits_addr:
                segments.append(proto)
                proto = None
        else:
            addr_size = proto.addr_size
            if addr_size is None:
                addr_size, _, b = varint.decode_raw(b)
            addr_value_bytes = bytes(b[:addr_size])
            b = b[addr_size:]
            segments.append(proto/addr_value_bytes)
            proto = None
    ma = Multiaddr(*segments)
    assert not ma.is_incomplete
    return ma</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="multiformats.multiaddr.raw" href="raw.html">multiformats.multiaddr.raw</a></code></dt>
<dd>
<div class="desc"><p>Implementation of raw encodings used by multiaddr protocols …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="multiformats.multiaddr.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>multiaddr_bytes: Union[bytes, bytearray, memoryview]) ‑> <a title="multiformats.multiaddr.Multiaddr" href="#multiformats.multiaddr.Multiaddr">Multiaddr</a></span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a multiaddr from its <code>(TLV)+</code> binary encoding.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; b = bytes.fromhex('047f00000191022382cc03')
&gt;&gt;&gt; multiaddr.decode(b)
Multiaddr(Addr('ip4', '127.0.0.1'), Addr('udp', '9090'), Proto('quic'))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(multiaddr_bytes: BytesLike) -&gt; Multiaddr:
    &#34;&#34;&#34;
        Decodes a multiaddr from its `(TLV)+` binary encoding.

        Example usage:

        ```py
        &gt;&gt;&gt; b = bytes.fromhex(&#39;047f00000191022382cc03&#39;)
        &gt;&gt;&gt; multiaddr.decode(b)
        Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Addr(&#39;udp&#39;, &#39;9090&#39;), Proto(&#39;quic&#39;))
        ```
    &#34;&#34;&#34;
    validate(multiaddr_bytes, BytesLike)
    b = memoryview(multiaddr_bytes)
    proto: Optional[Proto] = None
    segments: List[Union[Addr, Proto]] = []
    while len(b) &gt; 0:
        if proto is None:
            code, _, b = varint.decode_raw(b)
            proto = Proto(code)
            if not proto.admits_addr:
                segments.append(proto)
                proto = None
        else:
            addr_size = proto.addr_size
            if addr_size is None:
                addr_size, _, b = varint.decode_raw(b)
            addr_value_bytes = bytes(b[:addr_size])
            b = b[addr_size:]
            segments.append(proto/addr_value_bytes)
            proto = None
    ma = Multiaddr(*segments)
    assert not ma.is_incomplete
    return ma</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>multiaddr_str: str, allow_incomplete: bool = False) ‑> <a title="multiformats.multiaddr.Multiaddr" href="#multiformats.multiaddr.Multiaddr">Multiaddr</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parses a multiaddr from its human-readable string representation.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; s = '/ip4/127.0.0.1/udp/9090/quic'
&gt;&gt;&gt; multiaddr.parse(s)
Multiaddr(Addr('ip4', '127.0.0.1'), Addr('udp', '9090'), Proto('quic'))
</code></pre>
<p>Example usage with incomplete multiaddr:</p>
<pre><code class="language-py">&gt;&gt;&gt; s = '/ip4/127.0.0.1/udp'
&gt;&gt;&gt; multiaddr.parse(s)
ValueError: Decoded multiaddr is incomplete: /ip4/127.0.0.1/udp
&gt;&gt;&gt; multiaddr.parse(s, allow_incomplete=True)
Multiaddr(Addr('ip4', '127.0.0.1'), Proto('udp'))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(multiaddr_str: str, allow_incomplete: bool = False) -&gt; Multiaddr:
    &#34;&#34;&#34;
        Parses a multiaddr from its human-readable string representation.

        Example usage:

        ```py
        &gt;&gt;&gt; s = &#39;/ip4/127.0.0.1/udp/9090/quic&#39;
        &gt;&gt;&gt; multiaddr.parse(s)
        Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Addr(&#39;udp&#39;, &#39;9090&#39;), Proto(&#39;quic&#39;))
        ```

        Example usage with incomplete multiaddr:

        ```py
        &gt;&gt;&gt; s = &#39;/ip4/127.0.0.1/udp&#39;
        &gt;&gt;&gt; multiaddr.parse(s)
        ValueError: Decoded multiaddr is incomplete: /ip4/127.0.0.1/udp
        &gt;&gt;&gt; multiaddr.parse(s, allow_incomplete=True)
        Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Proto(&#39;udp&#39;))
        ```
    &#34;&#34;&#34;
    validate(multiaddr_str, str)
    validate(allow_incomplete, bool)
    tokens = multiaddr_str.split(&#34;/&#34;)
    proto: Optional[Proto] = None
    segments: List[Union[Addr, Proto]] = []
    for token in islice(tokens, 1, None):
        if proto is None:
            proto = Proto(token)
            if not proto.admits_addr:
                segments.append(proto)
                proto = None
        else:
            segments.append(proto/token)
            proto = None
    if proto is not None:
        segments.append(proto)
    ma = Multiaddr(*segments)
    if ma.is_incomplete and not allow_incomplete:
        raise ValueError(f&#34;Decoded multiaddr is incomplete: {str(ma)}&#34;)
    return ma</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.proto"><code class="name flex">
<span>def <span class="ident">proto</span></span>(<span>codec: Union[str, int, <a title="multiformats.multicodec.Multicodec" href="../multicodec/index.html#multiformats.multicodec.Multicodec">Multicodec</a>]) ‑> <a title="multiformats.multiaddr.Proto" href="#multiformats.multiaddr.Proto">Proto</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convenience function to construct a <code><a title="multiformats.multiaddr.Proto" href="#multiformats.multiaddr.Proto">Proto</a></code> instance.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4 = multiaddr.proto(&quot;ip4&quot;)
&gt;&gt;&gt; ip4
Proto(&quot;ip4&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def proto(codec: Union[str, int, Multicodec]) -&gt; Proto:
    &#34;&#34;&#34;
        Convenience function to construct a `Proto` instance.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4 = multiaddr.proto(&#34;ip4&#34;)
        &gt;&gt;&gt; ip4
        Proto(&#34;ip4&#34;)
        ```
    &#34;&#34;&#34;
    return Proto(codec)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="multiformats.multiaddr.Addr"><code class="flex name class">
<span>class <span class="ident">Addr</span></span>
<span>(</span><span>proto: Union[str, int, <a title="multiformats.multicodec.Multicodec" href="../multicodec/index.html#multiformats.multicodec.Multicodec">Multicodec</a>, <a title="multiformats.multiaddr.Proto" href="#multiformats.multiaddr.Proto">Proto</a>], value: Union[str, bytes, bytearray, memoryview])</span>
</code></dt>
<dd>
<div class="desc"><p>Container class for a single protocol address in a <a href="https://multiformats.io/multiaddr/">multiaddr</a>.</p>
<pre><code class="language-py">&gt;&gt;&gt; a = Addr('ip4', '192.168.1.1')
&gt;&gt;&gt; a
Addr('ip4', '192.168.1.1')
&gt;&gt;&gt; str(a)
'/ip4/192.168.1.1'
</code></pre>
<p>The slash notation provides a more literate way to construct protocol addresses:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = ip4/&quot;192.168.1.1&quot;
&gt;&gt;&gt; a
Addr('ip4', '192.168.1.1')
</code></pre>
<p>Bytes for protocol addresses are computed according to the TLV <a href="https://multiformats.io/multiaddr/">multiaddr format</a>:</p>
<pre><code class="language-py">&gt;&gt;&gt; bytes(ip4/&quot;127.0.0.1&quot;).hex()
'047f000001'
&gt;&gt;&gt; varint.encode(ip4.code).hex()
'04'
&gt;&gt;&gt; bytes([127, 0, 0, 1]).hex()
  '7f000001'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Addr:
    &#34;&#34;&#34;
        Container class for a single protocol address in a [multiaddr](https://multiformats.io/multiaddr/).

        ```py
        &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        &gt;&gt;&gt; a
        Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        &gt;&gt;&gt; str(a)
        &#39;/ip4/192.168.1.1&#39;
        ```

        The slash notation provides a more literate way to construct protocol addresses:

        ```py
        &gt;&gt;&gt; a = ip4/&#34;192.168.1.1&#34;
        &gt;&gt;&gt; a
        Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        ```

        Bytes for protocol addresses are computed according to the TLV [multiaddr format](https://multiformats.io/multiaddr/):

        ```py
        &gt;&gt;&gt; bytes(ip4/&#34;127.0.0.1&#34;).hex()
        &#39;047f000001&#39;
        &gt;&gt;&gt; varint.encode(ip4.code).hex()
        &#39;04&#39;
        &gt;&gt;&gt; bytes([127, 0, 0, 1]).hex()
          &#39;7f000001&#39;
        ```
    &#34;&#34;&#34;

    _proto: Proto
    _value: str
    _value_bytes: bytes

    __slots__ = (&#34;__weakref__&#34;, &#34;_proto&#34;, &#34;_value&#34;, &#34;_value_bytes&#34;)

    def __new__(cls, proto: Union[str, int, Multicodec, Proto], value: Union[str, BytesLike]) -&gt; &#34;Addr&#34;:
        if not isinstance(proto, Proto):
            proto = Proto(proto)
        value, value_bytes = proto.validate(value)
        instance: Addr = super().__new__(cls)
        instance._proto = proto
        instance._value = value
        instance._value_bytes = value_bytes
        return instance

    @property
    def proto(self) -&gt; Proto:
        &#34;&#34;&#34;
            The address protocol.

            Example usage:

            ```py
            &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            &gt;&gt;&gt; a.proto
            Proto(&#39;ip4&#39;)
            ```
        &#34;&#34;&#34;
        return self._proto

    @property
    def value(self) -&gt; str:
        &#34;&#34;&#34;
            The address value, as a string.

            Example usage:

            ```py
            &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            &gt;&gt;&gt; a.value
            &#39;192.168.1.1&#39;
            ```
        &#34;&#34;&#34;
        return self._value

    @property
    def value_bytes(self) -&gt; bytes:
        &#34;&#34;&#34;
            The address value, as bytes.

            Example usage:

            ```py
            &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            &gt;&gt;&gt; a.value_bytes
            b&#39;\\xc0\\xa8\\x01\\x01&#39;
            &gt;&gt;&gt; list(a.value_bytes)
            [192, 168, 1, 1]
            ```
        &#34;&#34;&#34;
        return self._value_bytes

    def __truediv__(self, other: Union[Proto, &#34;Addr&#34;, &#34;Multiaddr&#34;]) -&gt; &#34;Multiaddr&#34;:
        if isinstance(other, (Addr, Proto)):
            return Multiaddr(self, other)
        if isinstance(other, Multiaddr):
            return Multiaddr(self, *other)
        return NotImplemented

    def __str__(self) -&gt; str:
        return f&#34;{str(self.proto)}/{self.value}&#34;

    def __bytes__(self) -&gt; bytes:
        chunks: List[bytes] = []
        proto = self.proto
        value_bytes = self.value_bytes
        chunks.append(varint.encode(proto.code))
        if proto.addr_size is None:
            assert value_bytes is not None
            chunks.append(varint.encode(len(value_bytes)))
        chunks.append(value_bytes)
        return bytes(chain.from_iterable(chunks))

    def __repr__(self) -&gt; str:
        return f&#34;Addr({repr(self.proto.name)}, {repr(self.value)})&#34;

    @property
    def _as_tuple(self) -&gt; Tuple[Type[&#34;Addr&#34;], Proto, Optional[str]]:
        return (Addr, self.proto, self.value)

    def __hash__(self) -&gt; int:
        return hash(self._as_tuple)

    def __eq__(self, other: Any) -&gt; bool:
        if self is other:
            return True
        if not isinstance(other, Addr):
            return NotImplemented
        return self._as_tuple == other._as_tuple</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="multiformats.multiaddr.Addr.proto"><code class="name">var <span class="ident">proto</span> : <a title="multiformats.multiaddr.Proto" href="#multiformats.multiaddr.Proto">Proto</a></code></dt>
<dd>
<div class="desc"><p>The address protocol.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = Addr('ip4', '192.168.1.1')
&gt;&gt;&gt; a.proto
Proto('ip4')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def proto(self) -&gt; Proto:
    &#34;&#34;&#34;
        The address protocol.

        Example usage:

        ```py
        &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        &gt;&gt;&gt; a.proto
        Proto(&#39;ip4&#39;)
        ```
    &#34;&#34;&#34;
    return self._proto</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Addr.value"><code class="name">var <span class="ident">value</span> : str</code></dt>
<dd>
<div class="desc"><p>The address value, as a string.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = Addr('ip4', '192.168.1.1')
&gt;&gt;&gt; a.value
'192.168.1.1'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self) -&gt; str:
    &#34;&#34;&#34;
        The address value, as a string.

        Example usage:

        ```py
        &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        &gt;&gt;&gt; a.value
        &#39;192.168.1.1&#39;
        ```
    &#34;&#34;&#34;
    return self._value</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Addr.value_bytes"><code class="name">var <span class="ident">value_bytes</span> : bytes</code></dt>
<dd>
<div class="desc"><p>The address value, as bytes.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = Addr('ip4', '192.168.1.1')
&gt;&gt;&gt; a.value_bytes
b'\xc0\xa8\x01\x01'
&gt;&gt;&gt; list(a.value_bytes)
[192, 168, 1, 1]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value_bytes(self) -&gt; bytes:
    &#34;&#34;&#34;
        The address value, as bytes.

        Example usage:

        ```py
        &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        &gt;&gt;&gt; a.value_bytes
        b&#39;\\xc0\\xa8\\x01\\x01&#39;
        &gt;&gt;&gt; list(a.value_bytes)
        [192, 168, 1, 1]
        ```
    &#34;&#34;&#34;
    return self._value_bytes</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="multiformats.multiaddr.Multiaddr"><code class="flex name class">
<span>class <span class="ident">Multiaddr</span></span>
<span>(</span><span>*addrs: Union[<a title="multiformats.multiaddr.Addr" href="#multiformats.multiaddr.Addr">Addr</a>, <a title="multiformats.multiaddr.Proto" href="#multiformats.multiaddr.Proto">Proto</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Container class for a <a href="https://multiformats.io/multiaddr/">multiaddr</a>.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4 = Proto(&quot;ip4&quot;)
&gt;&gt;&gt; udp = Proto(&quot;udp&quot;)
&gt;&gt;&gt; quic = Proto(&quot;quic&quot;)
&gt;&gt;&gt; ma = ip4/&quot;127.0.0.1&quot;/udp/9090/quic
&gt;&gt;&gt; ma
Multiaddr(Addr('ip4', '127.0.0.1'), Addr('udp', '9090'), Proto('quic'))
&gt;&gt;&gt; str(ma)
'/ip4/127.0.0.1/udp/9090/quic'
</code></pre>
<p>Bytes for multiaddrs are computed according to the (TLV)+ <a href="https://multiformats.io/multiaddr/">multiaddr format</a>:</p>
<pre><code class="language-py">&gt;&gt;&gt; bytes(ip4/&quot;127.0.0.1&quot;).hex()
'047f000001'
&gt;&gt;&gt; bytes(udp/9090).hex()
          '91022382'
&gt;&gt;&gt; bytes(quic).hex()
                  'cc03'
&gt;&gt;&gt; bytes(ma).hex()
'047f00000191022382cc03'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Multiaddr(Sequence[Union[Addr, Proto]]):
    &#34;&#34;&#34;
        Container class for a [multiaddr](https://multiformats.io/multiaddr/).

        Example usage:

        ```py
        &gt;&gt;&gt; ip4 = Proto(&#34;ip4&#34;)
        &gt;&gt;&gt; udp = Proto(&#34;udp&#34;)
        &gt;&gt;&gt; quic = Proto(&#34;quic&#34;)
        &gt;&gt;&gt; ma = ip4/&#34;127.0.0.1&#34;/udp/9090/quic
        &gt;&gt;&gt; ma
        Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Addr(&#39;udp&#39;, &#39;9090&#39;), Proto(&#39;quic&#39;))
        &gt;&gt;&gt; str(ma)
        &#39;/ip4/127.0.0.1/udp/9090/quic&#39;
        ```

        Bytes for multiaddrs are computed according to the (TLV)+ [multiaddr format](https://multiformats.io/multiaddr/):

        ```py
        &gt;&gt;&gt; bytes(ip4/&#34;127.0.0.1&#34;).hex()
        &#39;047f000001&#39;
        &gt;&gt;&gt; bytes(udp/9090).hex()
                  &#39;91022382&#39;
        &gt;&gt;&gt; bytes(quic).hex()
                          &#39;cc03&#39;
        &gt;&gt;&gt; bytes(ma).hex()
        &#39;047f00000191022382cc03&#39;
        ```
    &#34;&#34;&#34;

    _addrs: Tuple[Union[Addr, Proto], ...]
    _proto_map: Dict[Proto, int]
    _is_incomplete: bool

    __slots__ = (&#34;__weakref__&#34;, &#34;_addrs&#34;, &#34;_proto_map&#34;, &#34;_is_incomplete&#34;)

    def __new__(cls, *addrs: Union[Addr, Proto]) -&gt; &#34;Multiaddr&#34;:
        l = len(addrs)
        is_incomplete = False
        proto_map: Dict[Proto, int] = {}
        for idx, addr in enumerate(addrs):
            if isinstance(addr, Proto):
                proto = addr
                if proto.addr_size != 0:
                    if idx == l-1:
                        is_incomplete = True
                    else:
                        raise ValueError(f&#34;Protocol {repr(proto.name)} expects an address, but is followed by another protocol instead.&#34;)
            else:
                validate(addr, Addr)
                proto = addr.proto
            if proto in proto_map:
                raise ValueError(f&#34;Protocol {repr(proto.name)} appears twice in multiaddr.&#34;)
            proto_map[proto] = idx
        instance: Multiaddr = super().__new__(cls)
        instance._addrs = addrs
        instance._proto_map = proto_map
        instance._is_incomplete = is_incomplete
        return instance

    @property
    def is_incomplete(self) -&gt; bool:
        &#34;&#34;&#34;
            Whether this multiaddress is incomplete, i.e. it still requires an address for
            the last protocol in the sequence.

            ```py
            &gt;&gt;&gt; ma = ip4/&#34;127.0.0.1&#34;/udp
            &gt;&gt;&gt; ma.is_incomplete
            True
            &gt;&gt;&gt; str(ma)
            &#39;/ip4/127.0.0.1/udp&#39;
            &gt;&gt;&gt; ma2 = ma/9090
            &gt;&gt;&gt; str(ma2)
            &#39;/ip4/127.0.0.1/udp/9090&#39;
            &gt;&gt;&gt; ma2.is_incomplete
            False
            ```

            Incomplete multiaddrs don&#39;t admit a byte representation:

            ```py
            &gt;&gt;&gt; bytes(ma)
            ValueError: Missing address value for last protocol, cannot compute bytes.
            &gt;&gt;&gt; bytes(ma2).hex()
            &#39;047f00000191022382&#39;
            ```
        &#34;&#34;&#34;
        return self._is_incomplete

    def index(self, value: Union[Addr, Proto], start: int = 0, stop: Optional[int] = None) -&gt; int:
        &#34;&#34;&#34;
            Returns the unique index at which a protocol/address appears in the multiaddress:

            ```py
            &gt;&gt;&gt; ma = ip4/&#34;127.0.0.1&#34;/udp/9090/quic
            &gt;&gt;&gt; str(ma)
            &#39;/ip4/127.0.0.1/udp/9090/quic&#39;
            &gt;&gt;&gt; udp in ma
            True
            &gt;&gt;&gt; ma.index(udp)
            1
            &gt;&gt;&gt; ma[ma.index(udp)]
            Addr(&#39;udp&#39;, &#39;9090&#39;)
            &gt;&gt;&gt; ip4/&#34;127.0.0.1&#34; in ma
            True
            &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.1&#34; in ma)
            0
            ```

            This method raises `ValueError` if the protocol/address does not appear:

            ```py
            &gt;&gt;&gt; ip6 = Proto(&#34;ip6&#34;)
            &gt;&gt;&gt; ip6 in ma
            False
            &gt;&gt;&gt; ma.index(ip6)
            ValueError: Protocol &#39;ip6&#39; does not appear in multiaddr /ip4/127.0.0.1/udp/9090/quic
            &gt;&gt;&gt; ip4/&#34;127.0.0.2&#34; in ma
            False
            &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.2&#34;)
            ValueError: Address Addr(&#39;ip4&#39;, &#39;127.0.0.2&#39;) does not appear in multiaddr /ip4/127.0.0.1/udp/9090/quic
            ```

            The optional `start` and `stop` arguments can be used to specify a range of indices
            within which to search for the protocol/address.

            ```py
            &gt;&gt;&gt; ip4/&#34;127.0.0.1&#34; in ma
            True
            &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.1&#34;)
            0
            &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.1&#34;, start=1)
            ValueError: Address Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;) does not appear in sub-multiaddr /udp/9090/quic of multiaddr /ip4/127.0.0.1/udp/9090/quic
            ```
        &#34;&#34;&#34;
        validate(start, int)
        if stop is None:
            stop = len(self)
        validate(stop, int)
        if isinstance(value, Proto):
            proto = value
        else:
            validate(value, Addr)
            proto = value.proto
        if proto not in self._proto_map:
            raise ValueError(f&#34;Protocol {repr(proto.name)} does not appear in multiaddr {str(self)}&#34;)
        idx = self._proto_map[proto]
        if isinstance(value, Addr):
            if self[idx] != value:
                raise ValueError(f&#34;Address {repr(value)} does not appear in multiaddr {str(self)}&#34;)
            if not start &lt;= idx &lt; stop:
                raise ValueError(f&#34;Address {repr(value)} does not appear in sub-multiaddr {str(self[start:stop])} &#34;
                                 f&#34;of multiaddr {str(self)}&#34;)
        return idx

    def __contains__(self, value: Any) -&gt; bool:
        if isinstance(value, (Addr, Proto)):
            try:
                self.index(value)
                return True
            except ValueError:
                return False
        return False

    def __len__(self) -&gt; int:
        return len(self._addrs)

    def __iter__(self) -&gt; Iterator[Union[Addr, Proto]]:
        return iter(self._addrs)

    @overload
    def __getitem__(self, idx: int) -&gt; Union[Addr, Proto]:
        ...

    @overload
    def __getitem__(self, idx: slice) -&gt; &#34;Multiaddr&#34;:
        ...

    def __getitem__(self, idx: Union[int, slice]) -&gt; Union[Addr, Proto, &#34;Multiaddr&#34;]:
        if isinstance(idx, int):
            return self._addrs[idx]
        validate(idx, slice)
        return Multiaddr(*self._addrs[idx])

    def __truediv__(self, other: Union[int, str, BytesLike, Addr, Proto, &#34;Multiaddr&#34;]) -&gt; &#34;Multiaddr&#34;:
        if isinstance(other, (int, str,)+byteslike):
            if not self.is_incomplete:
                raise ValueError(&#34;Unexpected address value. Expected Proto, Addr or Multiaddr.&#34;)
            addrs = list(self)
            tail_proto = addrs[-1]
            assert isinstance(tail_proto, Proto)
            return Multiaddr(*islice(addrs, 0, len(addrs)-1), tail_proto/other)
        if isinstance(other, (Addr, Proto)):
            if self.is_incomplete:
                raise ValueError(&#34;Expected address value (string or binary).&#34;)
            return Multiaddr(*self, other)
        if isinstance(other, Multiaddr):
            if self.is_incomplete:
                raise ValueError(&#34;Expected address value (string or binary).&#34;)
            return Multiaddr(*self, *other)
        return NotImplemented

    def __str__(self) -&gt; str:
        return &#34;&#34;.join(str(a) for a in self)

    def __bytes__(self) -&gt; bytes:
        if self.is_incomplete:
            raise ValueError(&#34;Missing address value for last protocol, cannot compute bytes.&#34;)
        return bytes(chain.from_iterable(bytes(addr) for addr in self))

    def __repr__(self) -&gt; str:
        return f&#34;Multiaddr({&#39;, &#39;.join(repr(a) for a in self)})&#34;

    @property
    def _as_tuple(self) -&gt; Tuple[Type[&#34;Multiaddr&#34;], Tuple[Union[Addr, Proto], ...]]:
        return (Multiaddr, self._addrs)

    def __hash__(self) -&gt; int:
        return hash(self._as_tuple)

    def __eq__(self, other: Any) -&gt; bool:
        if self is other:
            return True
        if not isinstance(other, Multiaddr):
            return NotImplemented
        return self._as_tuple == other._as_tuple</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="multiformats.multiaddr.Multiaddr.is_incomplete"><code class="name">var <span class="ident">is_incomplete</span> : bool</code></dt>
<dd>
<div class="desc"><p>Whether this multiaddress is incomplete, i.e. it still requires an address for
the last protocol in the sequence.</p>
<pre><code class="language-py">&gt;&gt;&gt; ma = ip4/&quot;127.0.0.1&quot;/udp
&gt;&gt;&gt; ma.is_incomplete
True
&gt;&gt;&gt; str(ma)
'/ip4/127.0.0.1/udp'
&gt;&gt;&gt; ma2 = ma/9090
&gt;&gt;&gt; str(ma2)
'/ip4/127.0.0.1/udp/9090'
&gt;&gt;&gt; ma2.is_incomplete
False
</code></pre>
<p>Incomplete multiaddrs don't admit a byte representation:</p>
<pre><code class="language-py">&gt;&gt;&gt; bytes(ma)
ValueError: Missing address value for last protocol, cannot compute bytes.
&gt;&gt;&gt; bytes(ma2).hex()
'047f00000191022382'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_incomplete(self) -&gt; bool:
    &#34;&#34;&#34;
        Whether this multiaddress is incomplete, i.e. it still requires an address for
        the last protocol in the sequence.

        ```py
        &gt;&gt;&gt; ma = ip4/&#34;127.0.0.1&#34;/udp
        &gt;&gt;&gt; ma.is_incomplete
        True
        &gt;&gt;&gt; str(ma)
        &#39;/ip4/127.0.0.1/udp&#39;
        &gt;&gt;&gt; ma2 = ma/9090
        &gt;&gt;&gt; str(ma2)
        &#39;/ip4/127.0.0.1/udp/9090&#39;
        &gt;&gt;&gt; ma2.is_incomplete
        False
        ```

        Incomplete multiaddrs don&#39;t admit a byte representation:

        ```py
        &gt;&gt;&gt; bytes(ma)
        ValueError: Missing address value for last protocol, cannot compute bytes.
        &gt;&gt;&gt; bytes(ma2).hex()
        &#39;047f00000191022382&#39;
        ```
    &#34;&#34;&#34;
    return self._is_incomplete</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="multiformats.multiaddr.Multiaddr.index"><code class="name flex">
<span>def <span class="ident">index</span></span>(<span>self, value: Union[<a title="multiformats.multiaddr.Addr" href="#multiformats.multiaddr.Addr">Addr</a>, <a title="multiformats.multiaddr.Proto" href="#multiformats.multiaddr.Proto">Proto</a>], start: int = 0, stop: Optional[None] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the unique index at which a protocol/address appears in the multiaddress:</p>
<pre><code class="language-py">&gt;&gt;&gt; ma = ip4/&quot;127.0.0.1&quot;/udp/9090/quic
&gt;&gt;&gt; str(ma)
'/ip4/127.0.0.1/udp/9090/quic'
&gt;&gt;&gt; udp in ma
True
&gt;&gt;&gt; ma.index(udp)
1
&gt;&gt;&gt; ma[ma.index(udp)]
Addr('udp', '9090')
&gt;&gt;&gt; ip4/&quot;127.0.0.1&quot; in ma
True
&gt;&gt;&gt; ma.index(ip4/&quot;127.0.0.1&quot; in ma)
0
</code></pre>
<p>This method raises <code>ValueError</code> if the protocol/address does not appear:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip6 = Proto(&quot;ip6&quot;)
&gt;&gt;&gt; ip6 in ma
False
&gt;&gt;&gt; ma.index(ip6)
ValueError: Protocol 'ip6' does not appear in multiaddr /ip4/127.0.0.1/udp/9090/quic
&gt;&gt;&gt; ip4/&quot;127.0.0.2&quot; in ma
False
&gt;&gt;&gt; ma.index(ip4/&quot;127.0.0.2&quot;)
ValueError: Address Addr('ip4', '127.0.0.2') does not appear in multiaddr /ip4/127.0.0.1/udp/9090/quic
</code></pre>
<p>The optional <code>start</code> and <code>stop</code> arguments can be used to specify a range of indices
within which to search for the protocol/address.</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4/&quot;127.0.0.1&quot; in ma
True
&gt;&gt;&gt; ma.index(ip4/&quot;127.0.0.1&quot;)
0
&gt;&gt;&gt; ma.index(ip4/&quot;127.0.0.1&quot;, start=1)
ValueError: Address Addr('ip4', '127.0.0.1') does not appear in sub-multiaddr /udp/9090/quic of multiaddr /ip4/127.0.0.1/udp/9090/quic
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index(self, value: Union[Addr, Proto], start: int = 0, stop: Optional[int] = None) -&gt; int:
    &#34;&#34;&#34;
        Returns the unique index at which a protocol/address appears in the multiaddress:

        ```py
        &gt;&gt;&gt; ma = ip4/&#34;127.0.0.1&#34;/udp/9090/quic
        &gt;&gt;&gt; str(ma)
        &#39;/ip4/127.0.0.1/udp/9090/quic&#39;
        &gt;&gt;&gt; udp in ma
        True
        &gt;&gt;&gt; ma.index(udp)
        1
        &gt;&gt;&gt; ma[ma.index(udp)]
        Addr(&#39;udp&#39;, &#39;9090&#39;)
        &gt;&gt;&gt; ip4/&#34;127.0.0.1&#34; in ma
        True
        &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.1&#34; in ma)
        0
        ```

        This method raises `ValueError` if the protocol/address does not appear:

        ```py
        &gt;&gt;&gt; ip6 = Proto(&#34;ip6&#34;)
        &gt;&gt;&gt; ip6 in ma
        False
        &gt;&gt;&gt; ma.index(ip6)
        ValueError: Protocol &#39;ip6&#39; does not appear in multiaddr /ip4/127.0.0.1/udp/9090/quic
        &gt;&gt;&gt; ip4/&#34;127.0.0.2&#34; in ma
        False
        &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.2&#34;)
        ValueError: Address Addr(&#39;ip4&#39;, &#39;127.0.0.2&#39;) does not appear in multiaddr /ip4/127.0.0.1/udp/9090/quic
        ```

        The optional `start` and `stop` arguments can be used to specify a range of indices
        within which to search for the protocol/address.

        ```py
        &gt;&gt;&gt; ip4/&#34;127.0.0.1&#34; in ma
        True
        &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.1&#34;)
        0
        &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.1&#34;, start=1)
        ValueError: Address Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;) does not appear in sub-multiaddr /udp/9090/quic of multiaddr /ip4/127.0.0.1/udp/9090/quic
        ```
    &#34;&#34;&#34;
    validate(start, int)
    if stop is None:
        stop = len(self)
    validate(stop, int)
    if isinstance(value, Proto):
        proto = value
    else:
        validate(value, Addr)
        proto = value.proto
    if proto not in self._proto_map:
        raise ValueError(f&#34;Protocol {repr(proto.name)} does not appear in multiaddr {str(self)}&#34;)
    idx = self._proto_map[proto]
    if isinstance(value, Addr):
        if self[idx] != value:
            raise ValueError(f&#34;Address {repr(value)} does not appear in multiaddr {str(self)}&#34;)
        if not start &lt;= idx &lt; stop:
            raise ValueError(f&#34;Address {repr(value)} does not appear in sub-multiaddr {str(self[start:stop])} &#34;
                             f&#34;of multiaddr {str(self)}&#34;)
    return idx</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="multiformats.multiaddr.Proto"><code class="flex name class">
<span>class <span class="ident">Proto</span></span>
<span>(</span><span>codec: Union[str, int, <a title="multiformats.multicodec.Multicodec" href="../multicodec/index.html#multiformats.multicodec.Multicodec">Multicodec</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Container class for a single protocol segment of a <a href="https://multiformats.io/multiaddr/">multiaddr</a>.</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4 = Proto(&quot;ip4&quot;)
&gt;&gt;&gt; ip4
Proto(&quot;ip4&quot;)
&gt;&gt;&gt; str(ip4)
'/ip4'
</code></pre>
<p>For protocols that don't require an address value, bytes are computed as the varint encoding of protocl code:</p>
<pre><code class="language-py">&gt;&gt;&gt; quic = Proto('quic')
&gt;&gt;&gt; quic.code
460
&gt;&gt;&gt; varint.encode(quic.code).hex()
'cc03'
&gt;&gt;&gt; bytes(quic).hex()
'cc03'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Proto:
    &#34;&#34;&#34;
        Container class for a single protocol segment of a [multiaddr](https://multiformats.io/multiaddr/).

        ```py
        &gt;&gt;&gt; ip4 = Proto(&#34;ip4&#34;)
        &gt;&gt;&gt; ip4
        Proto(&#34;ip4&#34;)
        &gt;&gt;&gt; str(ip4)
        &#39;/ip4&#39;
        ```

        For protocols that don&#39;t require an address value, bytes are computed as the varint encoding of protocl code:

        ```py
        &gt;&gt;&gt; quic = Proto(&#39;quic&#39;)
        &gt;&gt;&gt; quic.code
        460
        &gt;&gt;&gt; varint.encode(quic.code).hex()
        &#39;cc03&#39;
        &gt;&gt;&gt; bytes(quic).hex()
        &#39;cc03&#39;
        ```
    &#34;&#34;&#34;

    # WeakValueDictionary[str, &#34;Proto&#34;]
    _cache: ClassVar[WeakValueDictionary] = WeakValueDictionary() # type: ignore

    _codec: Multicodec
    _implementation: ProtoImpl

    __slots__ = (&#34;__weakref__&#34;, &#34;_codec&#34;, &#34;_implementation&#34;)

    def __new__(cls, codec: Union[str, int, Multicodec]) -&gt; &#34;Proto&#34;:
        # check that the codec exists:
        if isinstance(codec, str):
            codec = multicodec.get(codec)
        elif isinstance(codec, int):
            codec = multicodec.get(code=codec)
        else:
            validate(codec, Multicodec)
            existing_codec = multicodec.get(codec.name)
            if existing_codec != codec:
                raise ValueError(f&#34;Multicodec named {repr(codec.name)} exists, but is not the one given.&#34;)
            codec = existing_codec
        # check that the codec is a multiaddr multicodec:
        if codec.tag != &#34;multiaddr&#34;:
            raise ValueError(f&#34;Multicodec named {repr(codec.name)} exists, but is not a multiaddr.&#34;)
        implementation: ProtoImpl = raw.get(codec.name)
        _cache = Proto._cache
        if codec.name in _cache:
            # if a proto instance with this name is already registered
            instance: Proto = _cache[codec.name]
            if instance._codec == codec and instance._implementation == implementation:
                # nothing changed, can use the existing instance
                return instance
            # otherwise remove the existing instance
            del _cache[codec.name]
        # create a fresh instance, register it and return it
        instance = super().__new__(cls)
        instance._codec = codec
        instance._implementation = implementation
        _cache[codec.name] = instance
        return instance

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
            Protocol name.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.name
            &#39;ip4&#39;
            ```
        &#34;&#34;&#34;
        return self.codec.name

    @property
    def code(self) -&gt; int:
        &#34;&#34;&#34;
            Protocol code.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.code
            4
            # 4 = 0x04
            ```
        &#34;&#34;&#34;
        return self.codec.code

    @property
    def codec(self) -&gt; Multicodec:
        &#34;&#34;&#34;
            The multicodec for this protocol.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.codec
            Multicodec(name=&#39;ip4&#39;, tag=&#39;multiaddr&#39;, code=&#39;0x04&#39;,
                       status=&#39;permanent&#39;, description=&#39;&#39;)
            ```
        &#34;&#34;&#34;
        return self._codec

    @property
    def implementation(self) -&gt; ProtoImpl:
        &#34;&#34;&#34;
            The implementation for this protocol, as a triple of
            raw encoder, raw decoder and address size.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.implementation
            (
             &lt;function ip4_encoder at 0x000002B4C9956310&gt;,
             &lt;function ip4_decoder at 0x000002B4C99563A0&gt;,
             4
            )
            ```
        &#34;&#34;&#34;
        return self._implementation

    @property
    def raw_encoder(self) -&gt; Optional[RawEncoder]:
        &#34;&#34;&#34;
            The raw encoder for this protocol.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.raw_encoder
            &lt;function ip4_encoder at 0x000002B4C9956310&gt;
            ```
        &#34;&#34;&#34;
        return self.implementation[0]

    @property
    def raw_decoder(self) -&gt; Optional[RawDecoder]:
        &#34;&#34;&#34;
            The raw decoder for this protocol.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.raw_decoder
            &lt;function ip4_decoder at 0x000002B4C99563A0&gt;
            ```
        &#34;&#34;&#34;
        return self.implementation[1]

    @property
    def addr_size(self) -&gt; Optional[int]:
        &#34;&#34;&#34;
            The address size (in bytes) for this protocol:

            - for protocols with no address, `addr_size` is 0
            - for protocols with addresses of variable binary size, `addr_size` is `None`
            - for all other protocols, size is a positive `int`

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.addr_size
            4
            ```
        &#34;&#34;&#34;
        return self.implementation[2]

    @property
    def admits_addr(self) -&gt; bool:
        &#34;&#34;&#34;
            Whether this protocol admits an address.

            ```py
            &gt;&gt;&gt; ip4.admits_addr
            True
            ```
        &#34;&#34;&#34;
        return self.addr_size != 0

    def is_addr_valid(self, addr_value: Union[str, BytesLike]) -&gt; bool:
        &#34;&#34;&#34;
            Validates an address value.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.is_addr_valid(&#34;192.168.1.1&#34;)
            True
            &gt;&gt;&gt; ip4.is_addr_valid(bytes([192, 168, 1, 1]))
            True
            ```

            The same result can be obtained with container syntax:

            ```py
            &gt;&gt;&gt; &#34;192.168.1.1&#34; in ip4
            True
            &gt;&gt;&gt; bytes([192, 168, 1, 1]) in ip4
            True
            ```
        &#34;&#34;&#34;
        try:
            self.validate(addr_value)
            return True
        except AddressValueError:
            return False

    def validate(self, addr_value: Union[str, BytesLike]) -&gt; Tuple[str, bytes]:
        &#34;&#34;&#34;
            Raises `ValueError` if `not self.is_valid(addr_value)`.
            If successful, returns a pair of the string and bytes representations of the address value.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.validate(&#34;192.168.1.1&#34;)
            (&#39;192.168.1.1&#39;, b&#39;\\xc0\\xa8\\x01\\x01&#39;)
            &gt;&gt;&gt; ip4.validate(&#34;192.168&#34;)
            ipaddress.AddressValueError: Expected 4 octets in &#39;192.168&#39;
            ```
        &#34;&#34;&#34;
        raw_encoder, raw_decoder, addr_size = self.implementation
        if addr_size == 0:
            raise AddressValueError(f&#34;Protocol admits no address value, but {repr(addr_value)} was passed.&#34;)
        if isinstance(addr_value, byteslike):
            assert raw_decoder is not None
            addr_value_str = raw_decoder(addr_value) # raises AddressValueError if addr_value is invalid
            if not isinstance(addr_value, bytes):
                addr_value = bytes(addr_value)
            return addr_value_str, addr_value
        validate(addr_value, str)
        assert raw_encoder is not None
        addr_value_bytes = raw_encoder(addr_value) # raises AddressValueError if addr_value is invalid
        return addr_value, addr_value_bytes

    def addr(self, value: Union[str, BytesLike]) -&gt; &#34;Addr&#34;:
        &#34;&#34;&#34;
            Returns an address for this protocol.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.addr(&#34;192.168.1.1&#34;)
            Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            &gt;&gt;&gt; ip4.addr(bytes([192, 168, 1, 1]))
            Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            ```

            The same address can be obtained with slash syntax:

            ```py
            &gt;&gt;&gt; ip4/&#34;192.168.1.256&#34;
            Addr(&#39;ip4&#39;, &#39;192.168.1.256&#39;)
            &gt;&gt;&gt; ip4/b&#39;\\xc0\\xa8\\x01\\x01&#39;
            Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            ```
        &#34;&#34;&#34;
        return Addr(self, value)

    def __contains__(self, value: Union[str, BytesLike]) -&gt; bool:
        return self.is_addr_valid(value)

    @overload
    def __truediv__(self, value: Union[&#34;Proto&#34;, &#34;Addr&#34;, &#34;Multiaddr&#34;]) -&gt; &#34;Multiaddr&#34;:
        ...

    @overload
    def __truediv__(self, value: Union[int, str, BytesLike]) -&gt; &#34;Addr&#34;:
        ...

    def __truediv__(self, value: Union[int, str, BytesLike, &#34;Proto&#34;, &#34;Addr&#34;, &#34;Multiaddr&#34;]) -&gt; Union[&#34;Addr&#34;, &#34;Multiaddr&#34;]:
        if isinstance(value, int):
            value = str(value)
        if isinstance(value, (str,)+byteslike):
            return self.addr(value)
        if isinstance(value, (Addr, Proto)):
            return Multiaddr(self, value)
        if isinstance(value, Multiaddr):
            return Multiaddr(self, *value)
        return NotImplemented

    def __str__(self) -&gt; str:
        return f&#34;/{self.name}&#34;

    def __bytes__(self) -&gt; bytes:
        if self.addr_size != 0:
            raise ValueError(&#34;Missing address value for protocol, cannot compute bytes.&#34;)
        return varint.encode(self.code)

    def __repr__(self) -&gt; str:
        return f&#34;Proto({repr(self.name)})&#34;

    @property
    def _as_tuple(self) -&gt; Tuple[Type[&#34;Proto&#34;], Multicodec]:
        return (Proto, self.codec)

    def __hash__(self) -&gt; int:
        return hash(self._as_tuple)

    def __eq__(self, other: Any) -&gt; bool:
        if self is other:
            return True
        if not isinstance(other, Proto):
            return NotImplemented
        return self._as_tuple == other._as_tuple</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="multiformats.multiaddr.Proto.addr_size"><code class="name">var <span class="ident">addr_size</span> : Optional[None]</code></dt>
<dd>
<div class="desc"><p>The address size (in bytes) for this protocol:</p>
<ul>
<li>for protocols with no address, <code>addr_size</code> is 0</li>
<li>for protocols with addresses of variable binary size, <code>addr_size</code> is <code>None</code></li>
<li>for all other protocols, size is a positive <code>int</code></li>
</ul>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.addr_size
4
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def addr_size(self) -&gt; Optional[int]:
    &#34;&#34;&#34;
        The address size (in bytes) for this protocol:

        - for protocols with no address, `addr_size` is 0
        - for protocols with addresses of variable binary size, `addr_size` is `None`
        - for all other protocols, size is a positive `int`

        Example usage:

        ```py
        &gt;&gt;&gt; ip4.addr_size
        4
        ```
    &#34;&#34;&#34;
    return self.implementation[2]</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Proto.admits_addr"><code class="name">var <span class="ident">admits_addr</span> : bool</code></dt>
<dd>
<div class="desc"><p>Whether this protocol admits an address.</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.admits_addr
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def admits_addr(self) -&gt; bool:
    &#34;&#34;&#34;
        Whether this protocol admits an address.

        ```py
        &gt;&gt;&gt; ip4.admits_addr
        True
        ```
    &#34;&#34;&#34;
    return self.addr_size != 0</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Proto.code"><code class="name">var <span class="ident">code</span> : int</code></dt>
<dd>
<div class="desc"><p>Protocol code.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.code
4
# 4 = 0x04
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def code(self) -&gt; int:
    &#34;&#34;&#34;
        Protocol code.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4.code
        4
        # 4 = 0x04
        ```
    &#34;&#34;&#34;
    return self.codec.code</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Proto.codec"><code class="name">var <span class="ident">codec</span> : <a title="multiformats.multicodec.Multicodec" href="../multicodec/index.html#multiformats.multicodec.Multicodec">Multicodec</a></code></dt>
<dd>
<div class="desc"><p>The multicodec for this protocol.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.codec
Multicodec(name='ip4', tag='multiaddr', code='0x04',
           status='permanent', description='')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def codec(self) -&gt; Multicodec:
    &#34;&#34;&#34;
        The multicodec for this protocol.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4.codec
        Multicodec(name=&#39;ip4&#39;, tag=&#39;multiaddr&#39;, code=&#39;0x04&#39;,
                   status=&#39;permanent&#39;, description=&#39;&#39;)
        ```
    &#34;&#34;&#34;
    return self._codec</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Proto.implementation"><code class="name">var <span class="ident">implementation</span> : Tuple[Optional[Callable[[str], bytes]], Optional[Callable[[Union[bytes, bytearray, memoryview]], str]], Optional[int]]</code></dt>
<dd>
<div class="desc"><p>The implementation for this protocol, as a triple of
raw encoder, raw decoder and address size.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.implementation
(
 &lt;function ip4_encoder at 0x000002B4C9956310&gt;,
 &lt;function ip4_decoder at 0x000002B4C99563A0&gt;,
 4
)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def implementation(self) -&gt; ProtoImpl:
    &#34;&#34;&#34;
        The implementation for this protocol, as a triple of
        raw encoder, raw decoder and address size.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4.implementation
        (
         &lt;function ip4_encoder at 0x000002B4C9956310&gt;,
         &lt;function ip4_decoder at 0x000002B4C99563A0&gt;,
         4
        )
        ```
    &#34;&#34;&#34;
    return self._implementation</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Proto.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>Protocol name.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.name
'ip4'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;
        Protocol name.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4.name
        &#39;ip4&#39;
        ```
    &#34;&#34;&#34;
    return self.codec.name</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Proto.raw_decoder"><code class="name">var <span class="ident">raw_decoder</span> : Optional[Callable[[Union[bytes, bytearray, memoryview]], str]]</code></dt>
<dd>
<div class="desc"><p>The raw decoder for this protocol.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.raw_decoder
&lt;function ip4_decoder at 0x000002B4C99563A0&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_decoder(self) -&gt; Optional[RawDecoder]:
    &#34;&#34;&#34;
        The raw decoder for this protocol.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4.raw_decoder
        &lt;function ip4_decoder at 0x000002B4C99563A0&gt;
        ```
    &#34;&#34;&#34;
    return self.implementation[1]</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Proto.raw_encoder"><code class="name">var <span class="ident">raw_encoder</span> : Optional[Callable[[str], bytes]]</code></dt>
<dd>
<div class="desc"><p>The raw encoder for this protocol.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.raw_encoder
&lt;function ip4_encoder at 0x000002B4C9956310&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_encoder(self) -&gt; Optional[RawEncoder]:
    &#34;&#34;&#34;
        The raw encoder for this protocol.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4.raw_encoder
        &lt;function ip4_encoder at 0x000002B4C9956310&gt;
        ```
    &#34;&#34;&#34;
    return self.implementation[0]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="multiformats.multiaddr.Proto.addr"><code class="name flex">
<span>def <span class="ident">addr</span></span>(<span>self, value: Union[str, bytes, bytearray, memoryview]) ‑> <a title="multiformats.multiaddr.Addr" href="#multiformats.multiaddr.Addr">Addr</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns an address for this protocol.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.addr(&quot;192.168.1.1&quot;)
Addr('ip4', '192.168.1.1')
&gt;&gt;&gt; ip4.addr(bytes([192, 168, 1, 1]))
Addr('ip4', '192.168.1.1')
</code></pre>
<p>The same address can be obtained with slash syntax:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4/&quot;192.168.1.256&quot;
Addr('ip4', '192.168.1.256')
&gt;&gt;&gt; ip4/b'\xc0\xa8\x01\x01'
Addr('ip4', '192.168.1.1')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addr(self, value: Union[str, BytesLike]) -&gt; &#34;Addr&#34;:
    &#34;&#34;&#34;
        Returns an address for this protocol.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4.addr(&#34;192.168.1.1&#34;)
        Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        &gt;&gt;&gt; ip4.addr(bytes([192, 168, 1, 1]))
        Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        ```

        The same address can be obtained with slash syntax:

        ```py
        &gt;&gt;&gt; ip4/&#34;192.168.1.256&#34;
        Addr(&#39;ip4&#39;, &#39;192.168.1.256&#39;)
        &gt;&gt;&gt; ip4/b&#39;\\xc0\\xa8\\x01\\x01&#39;
        Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        ```
    &#34;&#34;&#34;
    return Addr(self, value)</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Proto.is_addr_valid"><code class="name flex">
<span>def <span class="ident">is_addr_valid</span></span>(<span>self, addr_value: Union[str, bytes, bytearray, memoryview]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Validates an address value.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.is_addr_valid(&quot;192.168.1.1&quot;)
True
&gt;&gt;&gt; ip4.is_addr_valid(bytes([192, 168, 1, 1]))
True
</code></pre>
<p>The same result can be obtained with container syntax:</p>
<pre><code class="language-py">&gt;&gt;&gt; &quot;192.168.1.1&quot; in ip4
True
&gt;&gt;&gt; bytes([192, 168, 1, 1]) in ip4
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_addr_valid(self, addr_value: Union[str, BytesLike]) -&gt; bool:
    &#34;&#34;&#34;
        Validates an address value.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4.is_addr_valid(&#34;192.168.1.1&#34;)
        True
        &gt;&gt;&gt; ip4.is_addr_valid(bytes([192, 168, 1, 1]))
        True
        ```

        The same result can be obtained with container syntax:

        ```py
        &gt;&gt;&gt; &#34;192.168.1.1&#34; in ip4
        True
        &gt;&gt;&gt; bytes([192, 168, 1, 1]) in ip4
        True
        ```
    &#34;&#34;&#34;
    try:
        self.validate(addr_value)
        return True
    except AddressValueError:
        return False</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Proto.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self, addr_value: Union[str, bytes, bytearray, memoryview]) ‑> Tuple[str, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Raises <code>ValueError</code> if <code>not self.is_valid(addr_value)</code>.
If successful, returns a pair of the string and bytes representations of the address value.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.validate(&quot;192.168.1.1&quot;)
('192.168.1.1', b'\xc0\xa8\x01\x01')
&gt;&gt;&gt; ip4.validate(&quot;192.168&quot;)
ipaddress.AddressValueError: Expected 4 octets in '192.168'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self, addr_value: Union[str, BytesLike]) -&gt; Tuple[str, bytes]:
    &#34;&#34;&#34;
        Raises `ValueError` if `not self.is_valid(addr_value)`.
        If successful, returns a pair of the string and bytes representations of the address value.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4.validate(&#34;192.168.1.1&#34;)
        (&#39;192.168.1.1&#39;, b&#39;\\xc0\\xa8\\x01\\x01&#39;)
        &gt;&gt;&gt; ip4.validate(&#34;192.168&#34;)
        ipaddress.AddressValueError: Expected 4 octets in &#39;192.168&#39;
        ```
    &#34;&#34;&#34;
    raw_encoder, raw_decoder, addr_size = self.implementation
    if addr_size == 0:
        raise AddressValueError(f&#34;Protocol admits no address value, but {repr(addr_value)} was passed.&#34;)
    if isinstance(addr_value, byteslike):
        assert raw_decoder is not None
        addr_value_str = raw_decoder(addr_value) # raises AddressValueError if addr_value is invalid
        if not isinstance(addr_value, bytes):
            addr_value = bytes(addr_value)
        return addr_value_str, addr_value
    validate(addr_value, str)
    assert raw_encoder is not None
    addr_value_bytes = raw_encoder(addr_value) # raises AddressValueError if addr_value is invalid
    return addr_value, addr_value_bytes</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="multiformats" href="../index.html">multiformats</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="multiformats.multiaddr.raw" href="raw.html">multiformats.multiaddr.raw</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="multiformats.multiaddr.decode" href="#multiformats.multiaddr.decode">decode</a></code></li>
<li><code><a title="multiformats.multiaddr.parse" href="#multiformats.multiaddr.parse">parse</a></code></li>
<li><code><a title="multiformats.multiaddr.proto" href="#multiformats.multiaddr.proto">proto</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="multiformats.multiaddr.Addr" href="#multiformats.multiaddr.Addr">Addr</a></code></h4>
<ul class="">
<li><code><a title="multiformats.multiaddr.Addr.proto" href="#multiformats.multiaddr.Addr.proto">proto</a></code></li>
<li><code><a title="multiformats.multiaddr.Addr.value" href="#multiformats.multiaddr.Addr.value">value</a></code></li>
<li><code><a title="multiformats.multiaddr.Addr.value_bytes" href="#multiformats.multiaddr.Addr.value_bytes">value_bytes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="multiformats.multiaddr.Multiaddr" href="#multiformats.multiaddr.Multiaddr">Multiaddr</a></code></h4>
<ul class="">
<li><code><a title="multiformats.multiaddr.Multiaddr.index" href="#multiformats.multiaddr.Multiaddr.index">index</a></code></li>
<li><code><a title="multiformats.multiaddr.Multiaddr.is_incomplete" href="#multiformats.multiaddr.Multiaddr.is_incomplete">is_incomplete</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="multiformats.multiaddr.Proto" href="#multiformats.multiaddr.Proto">Proto</a></code></h4>
<ul class="two-column">
<li><code><a title="multiformats.multiaddr.Proto.addr" href="#multiformats.multiaddr.Proto.addr">addr</a></code></li>
<li><code><a title="multiformats.multiaddr.Proto.addr_size" href="#multiformats.multiaddr.Proto.addr_size">addr_size</a></code></li>
<li><code><a title="multiformats.multiaddr.Proto.admits_addr" href="#multiformats.multiaddr.Proto.admits_addr">admits_addr</a></code></li>
<li><code><a title="multiformats.multiaddr.Proto.code" href="#multiformats.multiaddr.Proto.code">code</a></code></li>
<li><code><a title="multiformats.multiaddr.Proto.codec" href="#multiformats.multiaddr.Proto.codec">codec</a></code></li>
<li><code><a title="multiformats.multiaddr.Proto.implementation" href="#multiformats.multiaddr.Proto.implementation">implementation</a></code></li>
<li><code><a title="multiformats.multiaddr.Proto.is_addr_valid" href="#multiformats.multiaddr.Proto.is_addr_valid">is_addr_valid</a></code></li>
<li><code><a title="multiformats.multiaddr.Proto.name" href="#multiformats.multiaddr.Proto.name">name</a></code></li>
<li><code><a title="multiformats.multiaddr.Proto.raw_decoder" href="#multiformats.multiaddr.Proto.raw_decoder">raw_decoder</a></code></li>
<li><code><a title="multiformats.multiaddr.Proto.raw_encoder" href="#multiformats.multiaddr.Proto.raw_encoder">raw_encoder</a></code></li>
<li><code><a title="multiformats.multiaddr.Proto.validate" href="#multiformats.multiaddr.Proto.validate">validate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>