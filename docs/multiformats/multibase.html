<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>multiformats.multibase API documentation</title>
<meta name="description" content="Implementation of the [multibase spec](https://github.com/multiformats/multibase)." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>multiformats.multibase</code></h1>
</header>
<section id="section-intro">
<p>Implementation of the <a href="https://github.com/multiformats/multibase">multibase spec</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    Implementation of the [multibase spec](https://github.com/multiformats/multibase).
&#34;&#34;&#34;

from abc import ABC, abstractmethod
import base64
import binascii
import csv
from dataclasses import dataclass, field, InitVar
from importlib import resources
from itertools import product
import re
from typing import Callable, cast, Dict, Iterable, Iterator, List, Mapping, Optional, Tuple, Union

import base58

RawEncoder = Callable[[bytes], str]
RawDecoder = Callable[[str], bytes]

@dataclass(frozen=True)
class Encoding:
    &#34;&#34;&#34;
        Dataclass for a multibase encoding.

        Example usage:

Encoding.from_json({&#39;encoding&#39;: &#39;base8&#39;, &#39;code&#39;: &#39;7&#39;, &#39;status&#39;: &#39;draft&#39;, &#39;description&#39;: &#39;octal&#39;})

        ```py
            &gt;&gt;&gt; Encoding.from_json({
            ...     &#39;encoding&#39;: &#39;base8&#39;, &#39;code&#39;: &#39;7&#39;,
            ...     &#39;status&#39;: &#39;draft&#39;, &#39;description&#39;: &#39;octal&#39;})
            Encoding(encoding=&#39;base8&#39;, code=&#39;7&#39;,
                     status=&#39;draft&#39;, description=&#39;octal&#39;)
        ```

        Direct instantiation should be avoided: it is field-order dependent
        and might change without warning in the future.
    &#34;&#34;&#34;

    encoding: str
    &#34;&#34;&#34;
        Encoding name. Must satisfy the following:

        ```py
        re.match(r&#34;^[a-z][a-z0-9_-]+$&#34;, name)
        ```
    &#34;&#34;&#34;

    code: str
    &#34;&#34;&#34; Encoding code. Must be a single ASCII character.

        More specifically, it must be a single unicode codepoint satisfying:

        ```py
        ord(code) in range(0x00, 0x80)
        ```

    &#34;&#34;&#34;

    status: str
    &#34;&#34;&#34; Encoding status. Must be &#39;draft&#39;, &#39;candidate&#39; or &#39;default&#39;.&#34;&#34;&#34;

    description: str
    &#34;&#34;&#34; Encoding description. &#34;&#34;&#34;

    def __post_init__(self):
        if not re.match(r&#34;^[a-z][a-z0-9_-]+$&#34;, self.name): # ensure len(name) &gt; 1
            raise ValueError(f&#34;Invalid multibase encoding name {repr(self.name)}&#34;)
        if self.status not in (&#34;draft&#34;, &#34;candidate&#34;, &#34;default&#34;):
            raise ValueError(f&#34;Invalid multibase encoding status {repr(self.status)}.&#34;)
        if len(self.code) != 1:
            raise ValueError(f&#34;Invalid multibase encoding code {repr(self.code)} (length != 1).&#34;)
        if ord(self.code) not in range(0x00, 0x80):
            codepoint = hex(ord(self.code))[2:]
            if len(codepoint) % 2 != 0:
                codepoint = &#34;0&#34;+codepoint
            raise ValueError(f&#34;Invalid multibase encoding code &#39;\\x{codepoint}&#39;&#34;)

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
            An alias for the `Encoding.encoding` attribute.

            Using `Encoding.name` over `Encoding.encoding` is preferred, both for uniformity
            with the [multicodec spec](https://github.com/multiformats/multicodec) and
            to avoid potential confusion between encoding names (strings) and encoding
            objects (instances of `Encoding`).
        &#34;&#34;&#34;
        return self.encoding

    @property
    def raw_encoder(self) -&gt; RawEncoder:
        &#34;&#34;&#34;
            Returns the raw encoder for this encoding:
            given bytes, it produces the encoded string without the multibase prefix.
        &#34;&#34;&#34;
        if self.name not in _encoder_table:
            raise NotImplementedError(f&#34;Encoding using {self.name} is not yet implemented.&#34;)
        return _encoder_table[self.name]

    @property
    def raw_decoder(self) -&gt; RawDecoder:
        &#34;&#34;&#34;
            Returns the raw encoder for this encoding:
            given a string without the multibase prefix, it produces the decoded data.
        &#34;&#34;&#34;
        if self.name not in _decoder_table:
            raise NotImplementedError(f&#34;Decoding using {self.name} is not yet implemented.&#34;)
        return _decoder_table[self.name]

    def encode(self, data: bytes) -&gt; str:
        &#34;&#34;&#34;
            Encodes bytes into a multibase string: it first uses `Encoding.raw_encoder`,
            and then prepends the multibase prefix given by `Encoding.code` and returns
            the resulting multibase string.

            Example usage:

            ```py
            ```
        &#34;&#34;&#34;
        return self.code+self.raw_encoder(data)

    def decode(self, data: str) -&gt; bytes:
        &#34;&#34;&#34;
            Decodes a multibase string into bytes: it first checks that the multibase
            prefix matches the value specified by `Encoding.code`, then uses
            `Encoding.raw_encoder` on the string without prefix and returns the bytes.

            Example usage:

            ```py
            ```
        &#34;&#34;&#34;
        if data[0] != self.code:
            raise ValueError(f&#34;Expected {repr(self.name)} encoding, &#34;
                             f&#34;found {repr(get(data[0]).name)} encoding instead.&#34;)
        return self.raw_decoder(data[1:])

    def to_json(self) -&gt; Mapping[str, str]:
        &#34;&#34;&#34;
            Returns a JSON dictionary representation of this `Encoding` object,
            compatible with the one from the multibase.csv table found in the
            [multibase spec](https://github.com/multiformats/multibase).

            Example usage:

            ```py
            ```
        &#34;&#34;&#34;
        code = self.code
        if code not in range(0x20, 0x7F):
            code = hex(ord(code))
        return {
            &#34;encoding&#34;: self.encoding,
            &#34;code&#34;: code,
            &#34;status&#34;: self.status,
            &#34;description&#34;: self.description
        }

    @staticmethod
    def from_json(multibase_encoding: Mapping[str, Union[str, int]]) -&gt; &#34;Encoding&#34;:
        &#34;&#34;&#34;
            Creates an `Encoding` object from a JSON dictionary representation
            compatible with the one from the multibase.csv table found in the
            [multibase spec](https://github.com/multiformats/multibase).

            Example usage:

            ```py
            ```
        &#34;&#34;&#34;
        encoding = multibase_encoding[&#34;encoding&#34;]
        code = multibase_encoding[&#34;code&#34;]
        status = multibase_encoding[&#34;status&#34;]
        description = multibase_encoding[&#34;description&#34;]
        if not isinstance(encoding, str):
            raise TypeError(f&#34;Expected string, found {encoding = }.&#34;)
        if not isinstance(status, str):
            raise TypeError(f&#34;Expected string, found {status = }.&#34;)
        if not isinstance(description, str):
            raise TypeError(f&#34;Expected string, found {description = }.&#34;)
        if not isinstance(code, str):
            raise TypeError(f&#34;Expected string, found {code = }&#34;)
        if code.startswith(&#34;0x&#34;):
            code = chr(int(code, base=16))
        return Encoding(encoding, code, status, description)


def get(name_or_code: str) -&gt; Encoding:
    &#34;&#34;&#34;
        Gets the multibase encoding with given name (if a string of length &gt;= 2 is passed)
        or multibase code (if a string of length 1 is passed). Raises `ValueError` if the
        empty string is passed. Raises `KeyError` if no such encoding exists.

        Example usage:

        ```py
        &gt;&gt;&gt; multibase.get(&#34;base8&#34;)
        Encoding(encoding=&#39;base8&#39;, code=&#39;7&#39;,
                 status=&#39;draft&#39;, description=&#39;octal&#39;)
        &gt;&gt;&gt; multibase.get(&#39;t&#39;)
        Encoding(encoding=&#39;base32hexpad&#39;, code=&#39;t&#39;, status=&#39;candidate&#39;,
                 description=&#39;rfc4648 case-insensitive - with padding&#39;)
        ```
    &#34;&#34;&#34;
    if len(name_or_code) == 1:
        code = name_or_code
        if code not in _code_table:
            raise KeyError(f&#34;No multibase encoding with code {repr(code)}.&#34;)
        return _code_table[code]
    if len(name_or_code) == 0:
        raise ValueError(&#34;Empty string is neither a name nor a code.&#34;)
    name = name_or_code
    if name not in _name_table:
        raise KeyError(f&#34;No multibase encoding named {repr(name)}.&#34;)
    return _name_table[name]


def exists(name_or_code: str) -&gt; bool:
    &#34;&#34;&#34;
        Checks whether a multibase encoding with given name (if a string of length &gt;= 2 is passed)
        or multibase code (if a string of length 1 is passed) exists. Raises `ValueError` if the
        empty string is passed.

        Example usage:

        ```py
        &gt;&gt;&gt; multibase.exists(&#34;base8&#34;)
        True
        &gt;&gt;&gt; multibase.exists(&#39;t&#39;)
        True
        ```
    &#34;&#34;&#34;
    if len(name_or_code) == 1:
        code = name_or_code
        return code in _code_table
    if len(name_or_code) == 0:
        raise ValueError(&#34;Empty string is neither a name nor a code.&#34;)
    name = name_or_code
    return name in _name_table

def table() -&gt; Iterator[Encoding]:
    &#34;&#34;&#34;
        Iterates through the registered encodings, in order of ascending code.

        Example usage:

        ```py
        &gt;&gt;&gt; [e.code for e in multibase.table()]
        [&#39;\\x00&#39;, &#39;0&#39;, &#39;7&#39;, &#39;9&#39;, &#39;B&#39;, &#39;C&#39;, &#39;F&#39;, &#39;K&#39;, &#39;M&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;,
         &#39;Z&#39;,&#39;b&#39;, &#39;c&#39;, &#39;f&#39;, &#39;h&#39;, &#39;k&#39;, &#39;m&#39;, &#39;p&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;z&#39;]
        ```
    &#34;&#34;&#34;
    for code in sorted(_code_table.keys()):
        yield _code_table[code]

def encoding_of(data: str) -&gt; Encoding:
    &#34;&#34;&#34;
        Returns the multibase encoding for the data, according to the code specified by its first character.
        Raises `ValueError` if the empty string is passed.
        Raises `KeyError` if no encoding exists with that code.

        Example usage:

        ```py
        &gt;&gt;&gt; multibase.encoding_of(&#34;mSGVsbG8gd29ybGQh&#34;)
        Encoding(encoding=&#39;base64&#39;, code=&#39;m&#39;, status=&#39;default&#39;,
                 description=&#39;rfc4648 no padding&#39;)
        ```
    &#34;&#34;&#34;
    if len(data) == 0:
        raise ValueError(&#34;Empty string is not valid for encoded data.&#34;)
    code = data[0]
    return get(code)


def encode(data: bytes, encoding: Union[str, &#34;Encoding&#34;]) -&gt; str:
    &#34;&#34;&#34;
        Encodes the given bytes into a multibase string using the given encoding.
        If the encoding is passed by name or code (i.e. as a string), the `get`
        function is used to retrieve it. Encoding is performed by `Encoding.encode`.

        Example usage:

        ```py
        &gt;&gt;&gt; multibase.encode(b&#34;Hello world!&#34;, &#34;base64&#34;)
        &#39;mSGVsbG8gd29ybGQh&#39;
        ```
    &#34;&#34;&#34;
    if isinstance(encoding, str):
        name_or_code = encoding
        encoding = get(name_or_code)
    return encoding.encode(data)

def decode(data: str) -&gt; bytes:
    &#34;&#34;&#34;
        Decodes the given multibase string into bytes.
        The encoding is inferred using the `encoding_of` function.
        Decoding is then performed by `Encoding.decode`.

        Example usage:

        ```py
        &gt;&gt;&gt; multibase.decode(&#34;mSGVsbG8gd29ybGQh&#34;)
        b&#39;Hello world!&#39;
        ```
    &#34;&#34;&#34;
    encoding = encoding_of(data)
    return encoding.decode(data)


def build_multibase_tables(encodings: Iterable[Encoding]) -&gt; Tuple[Dict[str, Encoding], Dict[str, Encoding]]:
    &#34;&#34;&#34;
        Creates code-&gt;encoding and name-&gt;encoding mappings from a finite iterable of encodings, returning the mappings.

        Raises `ValueError` if the same encoding code or name is encountered multiple times

        Example usage:

        ```py
            code_table, name_table = build_multicodec_tables(encodings)
        ```
    &#34;&#34;&#34;
    code_table: Dict[str, Encoding] = {}
    name_table: Dict[str, Encoding] = {}
    for e in encodings:
        if e.code in code_table:
            raise ValueError(f&#34;Multicodec name {e.name} appears multiple times in table.&#34;)
        code_table[e.code] = e
        if e.name in name_table:
            raise ValueError(f&#34;Multicodec name {e.name} appears multiple times in table.&#34;)
        name_table[e.name] = e
    return code_table, name_table

# Create the global code-&gt;multicodec and name-&gt;multicodec mappings.
# _code_table: Dict[str, Encoding] = {}
# _name_table: Dict[str, Encoding] = {}
with resources.open_text(&#34;multiformats&#34;, &#34;multibase-table.csv&#34;) as csv_table:
    reader = csv.DictReader(csv_table)
    multicodecs = (Encoding.from_json({k.strip(): v.strip() for k, v in _row.items()})
                   for _row in reader)
    _code_table, _name_table = build_multibase_tables(multicodecs)

class RawEncoding(ABC):

    @abstractmethod
    def encode(self, b: bytes) -&gt; str:
        ...

    @abstractmethod
    def decode(self, s: str) -&gt; bytes:
        ...

class CustomRawEncoding(RawEncoding):

    _raw_encoder: Callable[[bytes], str]
    _raw_decoder: Callable[[str], bytes]

    def __init__(self, raw_encoder: Callable[[bytes], str], raw_decoder: Callable[[str], bytes]):
        self._raw_encoder = raw_encoder # type: ignore
        self._raw_decoder = raw_decoder # type: ignore

    def encode(self, b: bytes) -&gt; str:
        raw_encoder: Callable[[bytes], str] = self.raw_encoder # type: ignore
        return raw_encoder(b)

    def decode(self, s: str) -&gt; bytes:
        raw_decoder: Callable[[str], bytes] = self.raw_decoder # type: ignore
        return raw_decoder(s)


class AlphabeticRawEncoding(RawEncoding):
    &#34;&#34;&#34;
        Class for raw encodings analogous to base64, base32 and base16,
        described by [rfc4648](https://datatracker.ietf.org/doc/html/rfc4648.html).

        The constructor takes three positional parameters:

        1. `alphabet: str` is the encoding alphabet. It must not be empty, nor contain repeated characters.
           Characters allowed are all printable ASCII characters, except for the delete character, i.e.
           ```all(ord(c) not in range(0x20, 0x7F) for c in alphabet)```
        2. `group_nchars: int` is the number of characters in a group. Must be a positive integer.
           For example, the value in base64 is 4, while the value in base32 is 8.
        3. `group_nbytes: int` is the number of bytes in a group. Must be a positive integer.
           For example, the value in base64 is 3, while the value in base32 is 5.

        The constructor takes the following keyword-only arguments, all optional:

        - `pad_char: Optional[str] = None` is an optional character to be used as padding.
          For example, the value in both base64 and base32 is `&#34;=&#34;`.
          If `None`, a `binascii.Error` will be raised upon encoding if the encoded string requires padding.
          If `include_padding` is `False`, this has no effect upon encoding; however, the specified padding character
          is still counted as a legal character at the end of a string being decoded.
        - `include_padding: bool = True` determines whether padding will be included in encoded strings.
          If `False`, the result of `AlphabeticRawEncoding.encode` might be a string of incorrect length according
          to [rfc4648](https://datatracker.ietf.org/doc/html/rfc4648.html) (i.e. one with length which is not a miltiple of `group_nchars`).
        - `require_padding: bool = False` determines whether strings with an incorrect length (i.e. one with length which is
          not a multiple of `group_nchars`) should be rejected on decoding (raising `binascii.Error`).
        - `require_exact_bytes: bool = False` determines whether bytestrings with an incorrect length (i.e. one with length which is
          not a multiple of `group_nbytes`) should be rejected on encoding (raising `binascii.Error`).
    &#34;&#34;&#34;
    # pylint: disable = too-many-instance-attributes

    _alphabet: str
    _group_nchars: int
    _group_nbytes: int
    _pad_char: Optional[str]
    _include_padding: bool
    _require_padding: bool
    _require_exact_bytes: bool
    _lookup_table: Optional[Dict[bytes, str]]

    def __init__(self, alphabet: str, group_nchars: int, group_nbytes: int, *,
                 pad_char: Optional[str] = None, include_padding: bool = True, require_padding: bool = False,
                 require_exact_bytes: bool = False, lookup_table: bool = False):
        if len(alphabet) == 0:
            raise ValueError(&#34;Empty alphabet not allowed.&#34;)
        if len(alphabet) != len(set(alphabet)):
            raise ValueError(&#34;Repeated letters in the alphabet.&#34;)
        for c in alphabet:
            if ord(c) not in range(0x20, 0x7F):
                codepoint = hex(ord(c))[2:]
                if len(codepoint) % 2 != 0:
                    codepoint = &#34;0&#34;+codepoint
                raise ValueError(f&#34;Allowed characters are 0x20-0x7E (inclusive), found &#39;\\x{codepoint}&#39;&#34;)
        if group_nbytes &lt;= 0:
            raise ValueError(&#34;Number of bytes in a group must be a positive integer.&#34;)
        if group_nchars &lt;= 0:
            raise ValueError(&#34;Number of chars in a group must be a positive integer.&#34;)
        group_nbits = 8*group_nbytes
        if group_nbits%group_nchars != 0:
            raise ValueError(f&#34;Number of bits in a group ({group_nbits}) is not divisible &#34;
                             f&#34;by number of characters in a group ({group_nchars})&#34;)
        if pad_char is not None and len(pad_char) != 1:
            raise ValueError(&#34;If specified, padding character must be a string object of length 1.&#34;)
        self._alphabet = alphabet
        self._group_nchars = group_nchars
        self._group_nbytes = group_nbytes
        self._pad_char = pad_char
        self._include_padding = include_padding
        self._require_padding = require_padding
        self._require_exact_bytes = require_exact_bytes
        self._lookup_table = None
        if lookup_table:
            _lookup_table = {}
            for i in range(2**group_nbytes):
                byte_group = i.to_bytes(group_nbytes, byteorder=&#34;big&#34;)
                try:
                    _lookup_table[byte_group] = self.encode(byte_group)
                except binascii.Error:
                    pass
            self._lookup_table = _lookup_table

    def encode(self, b: bytes) -&gt; str:
        # pylint: disable = too-many-locals
        # extract encoding parameters
        group_nbytes = self._group_nbytes
        group_nchars = self._group_nchars
        pad_char = self._pad_char
        char_nbits = 8*group_nbytes//group_nchars
        char_bitmask = 2**char_nbits
        alphabet = self._alphabet
        lookup_table = self._lookup_table
        # compute padded length for bytes
        l = len(b)
        padding = 0
        zero_bytes = group_nbytes-l%group_nbytes
        if l%group_nbytes != 0:
            l += zero_bytes
            padding = zero_bytes*8//char_nbits
        if padding &gt; 0 and pad_char is None:
            raise binascii.Error(f&#34;Padding of length {padding} required, but no padding character.&#34;)
        # main loop: compute chars of encoded string
        chars: List[str] = []
        for b_idx in range(0, l, group_nbytes):
            # extract the next group of bytes, padding if necessary
            if b_idx+group_nbytes &lt;= len(b):
                byte_group = b[b_idx:b_idx+group_nbytes]
            else:
                byte_group = b[b_idx:]+b&#34;\x00&#34;*zero_bytes
            if lookup_table is not None:
                # get characters from precomputed lookup table
                if byte_group not in lookup_table:
                    raise binascii.Error(f&#34;Invalid byte group #{b_idx}.&#34;)
                chars.append(lookup_table[byte_group])
            else:
                # transform bytes into integer for easier bitwise manipulation
                group_int = int.from_bytes(byte_group, byteorder=&#34;big&#34;)
                # compute group characters, in reverse order
                revchars: List[str] = []
                for j in range(group_nchars):
                    if j &lt; padding:
                        # if padding &gt; 0, pad_char is not None
                        revchars.append(cast(str, pad_char))
                    else:
                        alphabet_idx = group_int%char_bitmask
                        if alphabet_idx &gt;= len(alphabet):
                            raise binascii.Error(f&#34;Invalid byte group #{b_idx}.&#34;)
                        revchars.append(alphabet[alphabet_idx])
                    group_int &gt;&gt;= char_nbits
                # append group characters to string, in correct order
                chars.append(&#34;&#34;.join(reversed(revchars)))
        # create and return encoded string
        return &#34;&#34;.join(chars)

    def decode(self, s: str) -&gt; bytes:
        ...

_alphabets = {
    &#34;base16&#34;: &#34;0123456789ABCDEF&#34;,
    &#34;base32&#34;: &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&#34;,
    &#34;base32hex&#34;: &#34;0123456789ABCDEFGHIJKLMNOPQRSTUV&#34;,
    &#34;base64&#34;: &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#34;,
    &#34;base64url&#34;: &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_&#34;
}

_raw_encodings: Dict[str, RawEncoding] = {
    &#34;identity&#34;: CustomRawEncoding(lambda b: b.decode(&#34;utf-8&#34;), lambda s: s.encode(&#34;utf-8&#34;)),
    &#34;base16&#34;: AlphabeticRawEncoding(_alphabets[&#34;base32&#34;], 2, 1, lookup_table=True),
    &#34;base32&#34;: AlphabeticRawEncoding(_alphabets[&#34;base32&#34;], 8, 5, pad_char=&#34;=&#34;),
    &#34;base32hex&#34;: AlphabeticRawEncoding(_alphabets[&#34;base32hex&#34;], 8, 5, pad_char=&#34;=&#34;),
    &#34;base64&#34;: AlphabeticRawEncoding(_alphabets[&#34;base64&#34;], 4, 3, pad_char=&#34;=&#34;),
    &#34;base64url&#34;: AlphabeticRawEncoding(_alphabets[&#34;base64url&#34;], 4, 3, pad_char=&#34;=&#34;),
}

# Utility functions
_b32pad = lambda s: s+&#34;=&#34;*(8-len(s)%8) if len(s)%8!=0 else s
_b64pad = lambda s: s+&#34;=&#34;*(4-len(s)%4) if len(s)%4!=0 else s
_b32nopad = lambda s: s.rstrip(&#34;=&#34;)
_b64nopad = _b32nopad



# Creates table of raw encoders
_encoder_table: Dict[str, RawEncoder] = {}

# identity encoder
_encoder_table[&#34;identity&#34;] = lambda b: b.decode(&#34;utf-8&#34;)

# base16 encoders
for _upper in [&#34;&#34;, &#34;upper&#34;]:
    encoder = lambda b: base64.b16encode(b).decode(&#34;utf-8&#34;)
    # encoder = _raw_encodings[&#34;base16&#34;].encode
    if not _upper:
        encoder = lambda b: encoder(b).lower()
    _encoder_table[f&#34;base16{_upper}&#34;] = encoder

# base32 encoders
for _hex, _pad, _upper in product([&#34;&#34;, &#34;hex&#34;], [&#34;&#34;, &#34;pad&#34;], [&#34;&#34;, &#34;upper&#34;]):
    if _hex:
        # base64.b32hexencode is available starting from Python 3.10
        encoder = _raw_encodings[&#34;base32hex&#34;].encode
    else:
        encoder = lambda b: base64.b32encode(b).decode(&#34;utf-8&#34;)
        # encoder = _raw_encodings[&#34;base32&#34;].encode
    if not _pad:
        encoder = lambda b: _b32nopad(encoder(b))
    if not _upper:
        encoder = lambda b: encoder(b).lower()
    _encoder_table[f&#34;base32{_hex}{_pad}{_upper}&#34;] = encoder

# print(_encoder_table[&#34;base32&#34;])

# base64 encoders
for _url, _pad in product([&#34;&#34;, &#34;url&#34;], [&#34;&#34;, &#34;pad&#34;]):
    if _url:
        encoder = lambda b: base64.urlsafe_b64encode(b).decode(&#34;utf-8&#34;)
    else:
        encoder = lambda b:  base64.standard_b64encode(b).decode(&#34;utf-8&#34;)
    if not _pad:
        encoder = lambda b: _b64nopad(encoder(b))
    _encoder_table[f&#34;base64{_url}{_pad}&#34;] = encoder


# Creates table of raw decoders

_decoder_table: Dict[str, RawDecoder] = {}

# identity decoder
_decoder_table[&#34;identity&#34;] = lambda s: s.encode(&#34;utf-8&#34;)


# base16 decoders
for _upper in [&#34;&#34;, &#34;upper&#34;]:
    decoder = lambda s: base64.b16decode(s.encode(&#34;utf-8&#34;), casefold=True)
    _decoder_table[f&#34;base16{_upper}&#34;] = decoder

# base32 decoders
for _hex, _pad, _upper in product([&#34;&#34;, &#34;hex&#34;], [&#34;&#34;, &#34;pad&#34;], [&#34;&#34;, &#34;upper&#34;]):
    decoder = lambda s: base64.b32decode(_b32pad(s).encode(&#34;utf-8&#34;), casefold=True)
    _decoder_table[f&#34;base32{_hex}{_pad}{_upper}&#34;] = decoder

# base64 decoders
for _url, _pad in product([&#34;&#34;, &#34;url&#34;], [&#34;&#34;, &#34;pad&#34;]):
    if _url:
        decoder = lambda s: base64.urlsafe_b64decode(_b64pad(s).encode(&#34;utf-8&#34;))
    else:
        decoder = lambda s: base64.standard_b64decode(_b64pad(s).encode(&#34;utf-8&#34;))
    _decoder_table[f&#34;base64{_url}{_pad}&#34;] = decoder

# base58 decoders</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="multiformats.multibase.build_multibase_tables"><code class="name flex">
<span>def <span class="ident">build_multibase_tables</span></span>(<span>encodings: Iterable[<a title="multiformats.multibase.Encoding" href="#multiformats.multibase.Encoding">Encoding</a>]) ‑> Tuple[Dict[str, <a title="multiformats.multibase.Encoding" href="#multiformats.multibase.Encoding">Encoding</a>], Dict[str, <a title="multiformats.multibase.Encoding" href="#multiformats.multibase.Encoding">Encoding</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates code-&gt;encoding and name-&gt;encoding mappings from a finite iterable of encodings, returning the mappings.</p>
<p>Raises <code>ValueError</code> if the same encoding code or name is encountered multiple times</p>
<p>Example usage:</p>
<pre><code class="language-py">    code_table, name_table = build_multicodec_tables(encodings)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_multibase_tables(encodings: Iterable[Encoding]) -&gt; Tuple[Dict[str, Encoding], Dict[str, Encoding]]:
    &#34;&#34;&#34;
        Creates code-&gt;encoding and name-&gt;encoding mappings from a finite iterable of encodings, returning the mappings.

        Raises `ValueError` if the same encoding code or name is encountered multiple times

        Example usage:

        ```py
            code_table, name_table = build_multicodec_tables(encodings)
        ```
    &#34;&#34;&#34;
    code_table: Dict[str, Encoding] = {}
    name_table: Dict[str, Encoding] = {}
    for e in encodings:
        if e.code in code_table:
            raise ValueError(f&#34;Multicodec name {e.name} appears multiple times in table.&#34;)
        code_table[e.code] = e
        if e.name in name_table:
            raise ValueError(f&#34;Multicodec name {e.name} appears multiple times in table.&#34;)
        name_table[e.name] = e
    return code_table, name_table</code></pre>
</details>
</dd>
<dt id="multiformats.multibase.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data: str) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes the given multibase string into bytes.
The encoding is inferred using the <code><a title="multiformats.multibase.encoding_of" href="#multiformats.multibase.encoding_of">encoding_of()</a></code> function.
Decoding is then performed by <code><a title="multiformats.multibase.Encoding.decode" href="#multiformats.multibase.Encoding.decode">Encoding.decode()</a></code>.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; multibase.decode(&quot;mSGVsbG8gd29ybGQh&quot;)
b'Hello world!'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(data: str) -&gt; bytes:
    &#34;&#34;&#34;
        Decodes the given multibase string into bytes.
        The encoding is inferred using the `encoding_of` function.
        Decoding is then performed by `Encoding.decode`.

        Example usage:

        ```py
        &gt;&gt;&gt; multibase.decode(&#34;mSGVsbG8gd29ybGQh&#34;)
        b&#39;Hello world!&#39;
        ```
    &#34;&#34;&#34;
    encoding = encoding_of(data)
    return encoding.decode(data)</code></pre>
</details>
</dd>
<dt id="multiformats.multibase.decoder"><code class="name flex">
<span>def <span class="ident">decoder</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">decoder = lambda s: base64.urlsafe_b64decode(_b64pad(s).encode(&#34;utf-8&#34;))</code></pre>
</details>
</dd>
<dt id="multiformats.multibase.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>data: bytes, encoding: Union[str, ForwardRef('<a title="multiformats.multibase.Encoding" href="#multiformats.multibase.Encoding">Encoding</a>')]) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes the given bytes into a multibase string using the given encoding.
If the encoding is passed by name or code (i.e. as a string), the <code><a title="multiformats.multibase.get" href="#multiformats.multibase.get">get()</a></code>
function is used to retrieve it. Encoding is performed by <code><a title="multiformats.multibase.Encoding.encode" href="#multiformats.multibase.Encoding.encode">Encoding.encode()</a></code>.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; multibase.encode(b&quot;Hello world!&quot;, &quot;base64&quot;)
'mSGVsbG8gd29ybGQh'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(data: bytes, encoding: Union[str, &#34;Encoding&#34;]) -&gt; str:
    &#34;&#34;&#34;
        Encodes the given bytes into a multibase string using the given encoding.
        If the encoding is passed by name or code (i.e. as a string), the `get`
        function is used to retrieve it. Encoding is performed by `Encoding.encode`.

        Example usage:

        ```py
        &gt;&gt;&gt; multibase.encode(b&#34;Hello world!&#34;, &#34;base64&#34;)
        &#39;mSGVsbG8gd29ybGQh&#39;
        ```
    &#34;&#34;&#34;
    if isinstance(encoding, str):
        name_or_code = encoding
        encoding = get(name_or_code)
    return encoding.encode(data)</code></pre>
</details>
</dd>
<dt id="multiformats.multibase.encoder"><code class="name flex">
<span>def <span class="ident">encoder</span></span>(<span>b)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">encoder = lambda b: base64.urlsafe_b64encode(b).decode(&#34;utf-8&#34;)</code></pre>
</details>
</dd>
<dt id="multiformats.multibase.encoding_of"><code class="name flex">
<span>def <span class="ident">encoding_of</span></span>(<span>data: str) ‑> <a title="multiformats.multibase.Encoding" href="#multiformats.multibase.Encoding">Encoding</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the multibase encoding for the data, according to the code specified by its first character.
Raises <code>ValueError</code> if the empty string is passed.
Raises <code>KeyError</code> if no encoding exists with that code.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; multibase.encoding_of(&quot;mSGVsbG8gd29ybGQh&quot;)
Encoding(encoding='base64', code='m', status='default',
         description='rfc4648 no padding')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encoding_of(data: str) -&gt; Encoding:
    &#34;&#34;&#34;
        Returns the multibase encoding for the data, according to the code specified by its first character.
        Raises `ValueError` if the empty string is passed.
        Raises `KeyError` if no encoding exists with that code.

        Example usage:

        ```py
        &gt;&gt;&gt; multibase.encoding_of(&#34;mSGVsbG8gd29ybGQh&#34;)
        Encoding(encoding=&#39;base64&#39;, code=&#39;m&#39;, status=&#39;default&#39;,
                 description=&#39;rfc4648 no padding&#39;)
        ```
    &#34;&#34;&#34;
    if len(data) == 0:
        raise ValueError(&#34;Empty string is not valid for encoded data.&#34;)
    code = data[0]
    return get(code)</code></pre>
</details>
</dd>
<dt id="multiformats.multibase.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>name_or_code: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether a multibase encoding with given name (if a string of length &gt;= 2 is passed)
or multibase code (if a string of length 1 is passed) exists. Raises <code>ValueError</code> if the
empty string is passed.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; multibase.exists(&quot;base8&quot;)
True
&gt;&gt;&gt; multibase.exists('t')
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists(name_or_code: str) -&gt; bool:
    &#34;&#34;&#34;
        Checks whether a multibase encoding with given name (if a string of length &gt;= 2 is passed)
        or multibase code (if a string of length 1 is passed) exists. Raises `ValueError` if the
        empty string is passed.

        Example usage:

        ```py
        &gt;&gt;&gt; multibase.exists(&#34;base8&#34;)
        True
        &gt;&gt;&gt; multibase.exists(&#39;t&#39;)
        True
        ```
    &#34;&#34;&#34;
    if len(name_or_code) == 1:
        code = name_or_code
        return code in _code_table
    if len(name_or_code) == 0:
        raise ValueError(&#34;Empty string is neither a name nor a code.&#34;)
    name = name_or_code
    return name in _name_table</code></pre>
</details>
</dd>
<dt id="multiformats.multibase.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>name_or_code: str) ‑> <a title="multiformats.multibase.Encoding" href="#multiformats.multibase.Encoding">Encoding</a></span>
</code></dt>
<dd>
<div class="desc"><p>Gets the multibase encoding with given name (if a string of length &gt;= 2 is passed)
or multibase code (if a string of length 1 is passed). Raises <code>ValueError</code> if the
empty string is passed. Raises <code>KeyError</code> if no such encoding exists.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; multibase.get(&quot;base8&quot;)
Encoding(encoding='base8', code='7',
         status='draft', description='octal')
&gt;&gt;&gt; multibase.get('t')
Encoding(encoding='base32hexpad', code='t', status='candidate',
         description='rfc4648 case-insensitive - with padding')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(name_or_code: str) -&gt; Encoding:
    &#34;&#34;&#34;
        Gets the multibase encoding with given name (if a string of length &gt;= 2 is passed)
        or multibase code (if a string of length 1 is passed). Raises `ValueError` if the
        empty string is passed. Raises `KeyError` if no such encoding exists.

        Example usage:

        ```py
        &gt;&gt;&gt; multibase.get(&#34;base8&#34;)
        Encoding(encoding=&#39;base8&#39;, code=&#39;7&#39;,
                 status=&#39;draft&#39;, description=&#39;octal&#39;)
        &gt;&gt;&gt; multibase.get(&#39;t&#39;)
        Encoding(encoding=&#39;base32hexpad&#39;, code=&#39;t&#39;, status=&#39;candidate&#39;,
                 description=&#39;rfc4648 case-insensitive - with padding&#39;)
        ```
    &#34;&#34;&#34;
    if len(name_or_code) == 1:
        code = name_or_code
        if code not in _code_table:
            raise KeyError(f&#34;No multibase encoding with code {repr(code)}.&#34;)
        return _code_table[code]
    if len(name_or_code) == 0:
        raise ValueError(&#34;Empty string is neither a name nor a code.&#34;)
    name = name_or_code
    if name not in _name_table:
        raise KeyError(f&#34;No multibase encoding named {repr(name)}.&#34;)
    return _name_table[name]</code></pre>
</details>
</dd>
<dt id="multiformats.multibase.table"><code class="name flex">
<span>def <span class="ident">table</span></span>(<span>) ‑> Iterator[<a title="multiformats.multibase.Encoding" href="#multiformats.multibase.Encoding">Encoding</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterates through the registered encodings, in order of ascending code.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; [e.code for e in multibase.table()]
['\x00', '0', '7', '9', 'B', 'C', 'F', 'K', 'M', 'T', 'U', 'V',
 'Z','b', 'c', 'f', 'h', 'k', 'm', 'p', 't', 'u', 'v', 'z']
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def table() -&gt; Iterator[Encoding]:
    &#34;&#34;&#34;
        Iterates through the registered encodings, in order of ascending code.

        Example usage:

        ```py
        &gt;&gt;&gt; [e.code for e in multibase.table()]
        [&#39;\\x00&#39;, &#39;0&#39;, &#39;7&#39;, &#39;9&#39;, &#39;B&#39;, &#39;C&#39;, &#39;F&#39;, &#39;K&#39;, &#39;M&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;,
         &#39;Z&#39;,&#39;b&#39;, &#39;c&#39;, &#39;f&#39;, &#39;h&#39;, &#39;k&#39;, &#39;m&#39;, &#39;p&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;z&#39;]
        ```
    &#34;&#34;&#34;
    for code in sorted(_code_table.keys()):
        yield _code_table[code]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="multiformats.multibase.AlphabeticRawEncoding"><code class="flex name class">
<span>class <span class="ident">AlphabeticRawEncoding</span></span>
<span>(</span><span>alphabet: str, group_nchars: int, group_nbytes: int, *, pad_char: Optional[str] = None, include_padding: bool = True, require_padding: bool = False, require_exact_bytes: bool = False, lookup_table: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for raw encodings analogous to base64, base32 and base16,
described by <a href="https://datatracker.ietf.org/doc/html/rfc4648.html">rfc4648</a>.</p>
<p>The constructor takes three positional parameters:</p>
<ol>
<li><code>alphabet: str</code> is the encoding alphabet. It must not be empty, nor contain repeated characters.
Characters allowed are all printable ASCII characters, except for the delete character, i.e.
<code>all(ord(c) not in range(0x20, 0x7F) for c in alphabet)</code></li>
<li><code>group_nchars: int</code> is the number of characters in a group. Must be a positive integer.
For example, the value in base64 is 4, while the value in base32 is 8.</li>
<li><code>group_nbytes: int</code> is the number of bytes in a group. Must be a positive integer.
For example, the value in base64 is 3, while the value in base32 is 5.</li>
</ol>
<p>The constructor takes the following keyword-only arguments, all optional:</p>
<ul>
<li><code>pad_char: Optional[str] = None</code> is an optional character to be used as padding.
For example, the value in both base64 and base32 is <code>"="</code>.
If <code>None</code>, a <code>binascii.Error</code> will be raised upon encoding if the encoded string requires padding.
If <code>include_padding</code> is <code>False</code>, this has no effect upon encoding; however, the specified padding character
is still counted as a legal character at the end of a string being decoded.</li>
<li><code>include_padding: bool = True</code> determines whether padding will be included in encoded strings.
If <code>False</code>, the result of <code><a title="multiformats.multibase.AlphabeticRawEncoding.encode" href="#multiformats.multibase.AlphabeticRawEncoding.encode">AlphabeticRawEncoding.encode()</a></code> might be a string of incorrect length according
to <a href="https://datatracker.ietf.org/doc/html/rfc4648.html">rfc4648</a> (i.e. one with length which is not a miltiple of <code>group_nchars</code>).</li>
<li><code>require_padding: bool = False</code> determines whether strings with an incorrect length (i.e. one with length which is
not a multiple of <code>group_nchars</code>) should be rejected on decoding (raising <code>binascii.Error</code>).</li>
<li><code>require_exact_bytes: bool = False</code> determines whether bytestrings with an incorrect length (i.e. one with length which is
not a multiple of <code>group_nbytes</code>) should be rejected on encoding (raising <code>binascii.Error</code>).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AlphabeticRawEncoding(RawEncoding):
    &#34;&#34;&#34;
        Class for raw encodings analogous to base64, base32 and base16,
        described by [rfc4648](https://datatracker.ietf.org/doc/html/rfc4648.html).

        The constructor takes three positional parameters:

        1. `alphabet: str` is the encoding alphabet. It must not be empty, nor contain repeated characters.
           Characters allowed are all printable ASCII characters, except for the delete character, i.e.
           ```all(ord(c) not in range(0x20, 0x7F) for c in alphabet)```
        2. `group_nchars: int` is the number of characters in a group. Must be a positive integer.
           For example, the value in base64 is 4, while the value in base32 is 8.
        3. `group_nbytes: int` is the number of bytes in a group. Must be a positive integer.
           For example, the value in base64 is 3, while the value in base32 is 5.

        The constructor takes the following keyword-only arguments, all optional:

        - `pad_char: Optional[str] = None` is an optional character to be used as padding.
          For example, the value in both base64 and base32 is `&#34;=&#34;`.
          If `None`, a `binascii.Error` will be raised upon encoding if the encoded string requires padding.
          If `include_padding` is `False`, this has no effect upon encoding; however, the specified padding character
          is still counted as a legal character at the end of a string being decoded.
        - `include_padding: bool = True` determines whether padding will be included in encoded strings.
          If `False`, the result of `AlphabeticRawEncoding.encode` might be a string of incorrect length according
          to [rfc4648](https://datatracker.ietf.org/doc/html/rfc4648.html) (i.e. one with length which is not a miltiple of `group_nchars`).
        - `require_padding: bool = False` determines whether strings with an incorrect length (i.e. one with length which is
          not a multiple of `group_nchars`) should be rejected on decoding (raising `binascii.Error`).
        - `require_exact_bytes: bool = False` determines whether bytestrings with an incorrect length (i.e. one with length which is
          not a multiple of `group_nbytes`) should be rejected on encoding (raising `binascii.Error`).
    &#34;&#34;&#34;
    # pylint: disable = too-many-instance-attributes

    _alphabet: str
    _group_nchars: int
    _group_nbytes: int
    _pad_char: Optional[str]
    _include_padding: bool
    _require_padding: bool
    _require_exact_bytes: bool
    _lookup_table: Optional[Dict[bytes, str]]

    def __init__(self, alphabet: str, group_nchars: int, group_nbytes: int, *,
                 pad_char: Optional[str] = None, include_padding: bool = True, require_padding: bool = False,
                 require_exact_bytes: bool = False, lookup_table: bool = False):
        if len(alphabet) == 0:
            raise ValueError(&#34;Empty alphabet not allowed.&#34;)
        if len(alphabet) != len(set(alphabet)):
            raise ValueError(&#34;Repeated letters in the alphabet.&#34;)
        for c in alphabet:
            if ord(c) not in range(0x20, 0x7F):
                codepoint = hex(ord(c))[2:]
                if len(codepoint) % 2 != 0:
                    codepoint = &#34;0&#34;+codepoint
                raise ValueError(f&#34;Allowed characters are 0x20-0x7E (inclusive), found &#39;\\x{codepoint}&#39;&#34;)
        if group_nbytes &lt;= 0:
            raise ValueError(&#34;Number of bytes in a group must be a positive integer.&#34;)
        if group_nchars &lt;= 0:
            raise ValueError(&#34;Number of chars in a group must be a positive integer.&#34;)
        group_nbits = 8*group_nbytes
        if group_nbits%group_nchars != 0:
            raise ValueError(f&#34;Number of bits in a group ({group_nbits}) is not divisible &#34;
                             f&#34;by number of characters in a group ({group_nchars})&#34;)
        if pad_char is not None and len(pad_char) != 1:
            raise ValueError(&#34;If specified, padding character must be a string object of length 1.&#34;)
        self._alphabet = alphabet
        self._group_nchars = group_nchars
        self._group_nbytes = group_nbytes
        self._pad_char = pad_char
        self._include_padding = include_padding
        self._require_padding = require_padding
        self._require_exact_bytes = require_exact_bytes
        self._lookup_table = None
        if lookup_table:
            _lookup_table = {}
            for i in range(2**group_nbytes):
                byte_group = i.to_bytes(group_nbytes, byteorder=&#34;big&#34;)
                try:
                    _lookup_table[byte_group] = self.encode(byte_group)
                except binascii.Error:
                    pass
            self._lookup_table = _lookup_table

    def encode(self, b: bytes) -&gt; str:
        # pylint: disable = too-many-locals
        # extract encoding parameters
        group_nbytes = self._group_nbytes
        group_nchars = self._group_nchars
        pad_char = self._pad_char
        char_nbits = 8*group_nbytes//group_nchars
        char_bitmask = 2**char_nbits
        alphabet = self._alphabet
        lookup_table = self._lookup_table
        # compute padded length for bytes
        l = len(b)
        padding = 0
        zero_bytes = group_nbytes-l%group_nbytes
        if l%group_nbytes != 0:
            l += zero_bytes
            padding = zero_bytes*8//char_nbits
        if padding &gt; 0 and pad_char is None:
            raise binascii.Error(f&#34;Padding of length {padding} required, but no padding character.&#34;)
        # main loop: compute chars of encoded string
        chars: List[str] = []
        for b_idx in range(0, l, group_nbytes):
            # extract the next group of bytes, padding if necessary
            if b_idx+group_nbytes &lt;= len(b):
                byte_group = b[b_idx:b_idx+group_nbytes]
            else:
                byte_group = b[b_idx:]+b&#34;\x00&#34;*zero_bytes
            if lookup_table is not None:
                # get characters from precomputed lookup table
                if byte_group not in lookup_table:
                    raise binascii.Error(f&#34;Invalid byte group #{b_idx}.&#34;)
                chars.append(lookup_table[byte_group])
            else:
                # transform bytes into integer for easier bitwise manipulation
                group_int = int.from_bytes(byte_group, byteorder=&#34;big&#34;)
                # compute group characters, in reverse order
                revchars: List[str] = []
                for j in range(group_nchars):
                    if j &lt; padding:
                        # if padding &gt; 0, pad_char is not None
                        revchars.append(cast(str, pad_char))
                    else:
                        alphabet_idx = group_int%char_bitmask
                        if alphabet_idx &gt;= len(alphabet):
                            raise binascii.Error(f&#34;Invalid byte group #{b_idx}.&#34;)
                        revchars.append(alphabet[alphabet_idx])
                    group_int &gt;&gt;= char_nbits
                # append group characters to string, in correct order
                chars.append(&#34;&#34;.join(reversed(revchars)))
        # create and return encoded string
        return &#34;&#34;.join(chars)

    def decode(self, s: str) -&gt; bytes:
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="multiformats.multibase.RawEncoding" href="#multiformats.multibase.RawEncoding">RawEncoding</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="multiformats.multibase.AlphabeticRawEncoding.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, s: str) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self, s: str) -&gt; bytes:
    ...</code></pre>
</details>
</dd>
<dt id="multiformats.multibase.AlphabeticRawEncoding.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self, b: bytes) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self, b: bytes) -&gt; str:
    # pylint: disable = too-many-locals
    # extract encoding parameters
    group_nbytes = self._group_nbytes
    group_nchars = self._group_nchars
    pad_char = self._pad_char
    char_nbits = 8*group_nbytes//group_nchars
    char_bitmask = 2**char_nbits
    alphabet = self._alphabet
    lookup_table = self._lookup_table
    # compute padded length for bytes
    l = len(b)
    padding = 0
    zero_bytes = group_nbytes-l%group_nbytes
    if l%group_nbytes != 0:
        l += zero_bytes
        padding = zero_bytes*8//char_nbits
    if padding &gt; 0 and pad_char is None:
        raise binascii.Error(f&#34;Padding of length {padding} required, but no padding character.&#34;)
    # main loop: compute chars of encoded string
    chars: List[str] = []
    for b_idx in range(0, l, group_nbytes):
        # extract the next group of bytes, padding if necessary
        if b_idx+group_nbytes &lt;= len(b):
            byte_group = b[b_idx:b_idx+group_nbytes]
        else:
            byte_group = b[b_idx:]+b&#34;\x00&#34;*zero_bytes
        if lookup_table is not None:
            # get characters from precomputed lookup table
            if byte_group not in lookup_table:
                raise binascii.Error(f&#34;Invalid byte group #{b_idx}.&#34;)
            chars.append(lookup_table[byte_group])
        else:
            # transform bytes into integer for easier bitwise manipulation
            group_int = int.from_bytes(byte_group, byteorder=&#34;big&#34;)
            # compute group characters, in reverse order
            revchars: List[str] = []
            for j in range(group_nchars):
                if j &lt; padding:
                    # if padding &gt; 0, pad_char is not None
                    revchars.append(cast(str, pad_char))
                else:
                    alphabet_idx = group_int%char_bitmask
                    if alphabet_idx &gt;= len(alphabet):
                        raise binascii.Error(f&#34;Invalid byte group #{b_idx}.&#34;)
                    revchars.append(alphabet[alphabet_idx])
                group_int &gt;&gt;= char_nbits
            # append group characters to string, in correct order
            chars.append(&#34;&#34;.join(reversed(revchars)))
    # create and return encoded string
    return &#34;&#34;.join(chars)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="multiformats.multibase.CustomRawEncoding"><code class="flex name class">
<span>class <span class="ident">CustomRawEncoding</span></span>
<span>(</span><span>raw_encoder: Callable[[bytes], str], raw_decoder: Callable[[str], bytes])</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CustomRawEncoding(RawEncoding):

    _raw_encoder: Callable[[bytes], str]
    _raw_decoder: Callable[[str], bytes]

    def __init__(self, raw_encoder: Callable[[bytes], str], raw_decoder: Callable[[str], bytes]):
        self._raw_encoder = raw_encoder # type: ignore
        self._raw_decoder = raw_decoder # type: ignore

    def encode(self, b: bytes) -&gt; str:
        raw_encoder: Callable[[bytes], str] = self.raw_encoder # type: ignore
        return raw_encoder(b)

    def decode(self, s: str) -&gt; bytes:
        raw_decoder: Callable[[str], bytes] = self.raw_decoder # type: ignore
        return raw_decoder(s)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="multiformats.multibase.RawEncoding" href="#multiformats.multibase.RawEncoding">RawEncoding</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="multiformats.multibase.CustomRawEncoding.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, s: str) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self, s: str) -&gt; bytes:
    raw_decoder: Callable[[str], bytes] = self.raw_decoder # type: ignore
    return raw_decoder(s)</code></pre>
</details>
</dd>
<dt id="multiformats.multibase.CustomRawEncoding.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self, b: bytes) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self, b: bytes) -&gt; str:
    raw_encoder: Callable[[bytes], str] = self.raw_encoder # type: ignore
    return raw_encoder(b)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="multiformats.multibase.Encoding"><code class="flex name class">
<span>class <span class="ident">Encoding</span></span>
<span>(</span><span>encoding: str, code: str, status: str, description: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Dataclass for a multibase encoding.</p>
<pre><code>    Example usage:
</code></pre>
<p>Encoding.from_json({'encoding': 'base8', 'code': '7', 'status': 'draft', 'description': 'octal'})</p>
<pre><code>    ```py
        &gt;&gt;&gt; Encoding.from_json({
        ...     'encoding': 'base8', 'code': '7',
        ...     'status': 'draft', 'description': 'octal'})
        Encoding(encoding='base8', code='7',
                 status='draft', description='octal')
    ```

    Direct instantiation should be avoided: it is field-order dependent
    and might change without warning in the future.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class Encoding:
    &#34;&#34;&#34;
        Dataclass for a multibase encoding.

        Example usage:

Encoding.from_json({&#39;encoding&#39;: &#39;base8&#39;, &#39;code&#39;: &#39;7&#39;, &#39;status&#39;: &#39;draft&#39;, &#39;description&#39;: &#39;octal&#39;})

        ```py
            &gt;&gt;&gt; Encoding.from_json({
            ...     &#39;encoding&#39;: &#39;base8&#39;, &#39;code&#39;: &#39;7&#39;,
            ...     &#39;status&#39;: &#39;draft&#39;, &#39;description&#39;: &#39;octal&#39;})
            Encoding(encoding=&#39;base8&#39;, code=&#39;7&#39;,
                     status=&#39;draft&#39;, description=&#39;octal&#39;)
        ```

        Direct instantiation should be avoided: it is field-order dependent
        and might change without warning in the future.
    &#34;&#34;&#34;

    encoding: str
    &#34;&#34;&#34;
        Encoding name. Must satisfy the following:

        ```py
        re.match(r&#34;^[a-z][a-z0-9_-]+$&#34;, name)
        ```
    &#34;&#34;&#34;

    code: str
    &#34;&#34;&#34; Encoding code. Must be a single ASCII character.

        More specifically, it must be a single unicode codepoint satisfying:

        ```py
        ord(code) in range(0x00, 0x80)
        ```

    &#34;&#34;&#34;

    status: str
    &#34;&#34;&#34; Encoding status. Must be &#39;draft&#39;, &#39;candidate&#39; or &#39;default&#39;.&#34;&#34;&#34;

    description: str
    &#34;&#34;&#34; Encoding description. &#34;&#34;&#34;

    def __post_init__(self):
        if not re.match(r&#34;^[a-z][a-z0-9_-]+$&#34;, self.name): # ensure len(name) &gt; 1
            raise ValueError(f&#34;Invalid multibase encoding name {repr(self.name)}&#34;)
        if self.status not in (&#34;draft&#34;, &#34;candidate&#34;, &#34;default&#34;):
            raise ValueError(f&#34;Invalid multibase encoding status {repr(self.status)}.&#34;)
        if len(self.code) != 1:
            raise ValueError(f&#34;Invalid multibase encoding code {repr(self.code)} (length != 1).&#34;)
        if ord(self.code) not in range(0x00, 0x80):
            codepoint = hex(ord(self.code))[2:]
            if len(codepoint) % 2 != 0:
                codepoint = &#34;0&#34;+codepoint
            raise ValueError(f&#34;Invalid multibase encoding code &#39;\\x{codepoint}&#39;&#34;)

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
            An alias for the `Encoding.encoding` attribute.

            Using `Encoding.name` over `Encoding.encoding` is preferred, both for uniformity
            with the [multicodec spec](https://github.com/multiformats/multicodec) and
            to avoid potential confusion between encoding names (strings) and encoding
            objects (instances of `Encoding`).
        &#34;&#34;&#34;
        return self.encoding

    @property
    def raw_encoder(self) -&gt; RawEncoder:
        &#34;&#34;&#34;
            Returns the raw encoder for this encoding:
            given bytes, it produces the encoded string without the multibase prefix.
        &#34;&#34;&#34;
        if self.name not in _encoder_table:
            raise NotImplementedError(f&#34;Encoding using {self.name} is not yet implemented.&#34;)
        return _encoder_table[self.name]

    @property
    def raw_decoder(self) -&gt; RawDecoder:
        &#34;&#34;&#34;
            Returns the raw encoder for this encoding:
            given a string without the multibase prefix, it produces the decoded data.
        &#34;&#34;&#34;
        if self.name not in _decoder_table:
            raise NotImplementedError(f&#34;Decoding using {self.name} is not yet implemented.&#34;)
        return _decoder_table[self.name]

    def encode(self, data: bytes) -&gt; str:
        &#34;&#34;&#34;
            Encodes bytes into a multibase string: it first uses `Encoding.raw_encoder`,
            and then prepends the multibase prefix given by `Encoding.code` and returns
            the resulting multibase string.

            Example usage:

            ```py
            ```
        &#34;&#34;&#34;
        return self.code+self.raw_encoder(data)

    def decode(self, data: str) -&gt; bytes:
        &#34;&#34;&#34;
            Decodes a multibase string into bytes: it first checks that the multibase
            prefix matches the value specified by `Encoding.code`, then uses
            `Encoding.raw_encoder` on the string without prefix and returns the bytes.

            Example usage:

            ```py
            ```
        &#34;&#34;&#34;
        if data[0] != self.code:
            raise ValueError(f&#34;Expected {repr(self.name)} encoding, &#34;
                             f&#34;found {repr(get(data[0]).name)} encoding instead.&#34;)
        return self.raw_decoder(data[1:])

    def to_json(self) -&gt; Mapping[str, str]:
        &#34;&#34;&#34;
            Returns a JSON dictionary representation of this `Encoding` object,
            compatible with the one from the multibase.csv table found in the
            [multibase spec](https://github.com/multiformats/multibase).

            Example usage:

            ```py
            ```
        &#34;&#34;&#34;
        code = self.code
        if code not in range(0x20, 0x7F):
            code = hex(ord(code))
        return {
            &#34;encoding&#34;: self.encoding,
            &#34;code&#34;: code,
            &#34;status&#34;: self.status,
            &#34;description&#34;: self.description
        }

    @staticmethod
    def from_json(multibase_encoding: Mapping[str, Union[str, int]]) -&gt; &#34;Encoding&#34;:
        &#34;&#34;&#34;
            Creates an `Encoding` object from a JSON dictionary representation
            compatible with the one from the multibase.csv table found in the
            [multibase spec](https://github.com/multiformats/multibase).

            Example usage:

            ```py
            ```
        &#34;&#34;&#34;
        encoding = multibase_encoding[&#34;encoding&#34;]
        code = multibase_encoding[&#34;code&#34;]
        status = multibase_encoding[&#34;status&#34;]
        description = multibase_encoding[&#34;description&#34;]
        if not isinstance(encoding, str):
            raise TypeError(f&#34;Expected string, found {encoding = }.&#34;)
        if not isinstance(status, str):
            raise TypeError(f&#34;Expected string, found {status = }.&#34;)
        if not isinstance(description, str):
            raise TypeError(f&#34;Expected string, found {description = }.&#34;)
        if not isinstance(code, str):
            raise TypeError(f&#34;Expected string, found {code = }&#34;)
        if code.startswith(&#34;0x&#34;):
            code = chr(int(code, base=16))
        return Encoding(encoding, code, status, description)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="multiformats.multibase.Encoding.code"><code class="name">var <span class="ident">code</span> : str</code></dt>
<dd>
<div class="desc"><p>Encoding code. Must be a single ASCII character.</p>
<p>More specifically, it must be a single unicode codepoint satisfying:</p>
<pre><code class="language-py">ord(code) in range(0x00, 0x80)
</code></pre></div>
</dd>
<dt id="multiformats.multibase.Encoding.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"><p>Encoding description.</p></div>
</dd>
<dt id="multiformats.multibase.Encoding.encoding"><code class="name">var <span class="ident">encoding</span> : str</code></dt>
<dd>
<div class="desc"><p>Encoding name. Must satisfy the following:</p>
<pre><code class="language-py">re.match(r&quot;^[a-z][a-z0-9_-]+$&quot;, name)
</code></pre></div>
</dd>
<dt id="multiformats.multibase.Encoding.status"><code class="name">var <span class="ident">status</span> : str</code></dt>
<dd>
<div class="desc"><p>Encoding status. Must be 'draft', 'candidate' or 'default'.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="multiformats.multibase.Encoding.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>multibase_encoding: Mapping[str, Union[str, int]]) ‑> <a title="multiformats.multibase.Encoding" href="#multiformats.multibase.Encoding">Encoding</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an <code><a title="multiformats.multibase.Encoding" href="#multiformats.multibase.Encoding">Encoding</a></code> object from a JSON dictionary representation
compatible with the one from the multibase.csv table found in the
<a href="https://github.com/multiformats/multibase">multibase spec</a>.</p>
<p>Example usage:</p>
<pre><code class="language-py"></code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(multibase_encoding: Mapping[str, Union[str, int]]) -&gt; &#34;Encoding&#34;:
    &#34;&#34;&#34;
        Creates an `Encoding` object from a JSON dictionary representation
        compatible with the one from the multibase.csv table found in the
        [multibase spec](https://github.com/multiformats/multibase).

        Example usage:

        ```py
        ```
    &#34;&#34;&#34;
    encoding = multibase_encoding[&#34;encoding&#34;]
    code = multibase_encoding[&#34;code&#34;]
    status = multibase_encoding[&#34;status&#34;]
    description = multibase_encoding[&#34;description&#34;]
    if not isinstance(encoding, str):
        raise TypeError(f&#34;Expected string, found {encoding = }.&#34;)
    if not isinstance(status, str):
        raise TypeError(f&#34;Expected string, found {status = }.&#34;)
    if not isinstance(description, str):
        raise TypeError(f&#34;Expected string, found {description = }.&#34;)
    if not isinstance(code, str):
        raise TypeError(f&#34;Expected string, found {code = }&#34;)
    if code.startswith(&#34;0x&#34;):
        code = chr(int(code, base=16))
    return Encoding(encoding, code, status, description)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="multiformats.multibase.Encoding.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>An alias for the <code><a title="multiformats.multibase.Encoding.encoding" href="#multiformats.multibase.Encoding.encoding">Encoding.encoding</a></code> attribute.</p>
<p>Using <code><a title="multiformats.multibase.Encoding.name" href="#multiformats.multibase.Encoding.name">Encoding.name</a></code> over <code><a title="multiformats.multibase.Encoding.encoding" href="#multiformats.multibase.Encoding.encoding">Encoding.encoding</a></code> is preferred, both for uniformity
with the <a href="https://github.com/multiformats/multicodec">multicodec spec</a> and
to avoid potential confusion between encoding names (strings) and encoding
objects (instances of <code><a title="multiformats.multibase.Encoding" href="#multiformats.multibase.Encoding">Encoding</a></code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;
        An alias for the `Encoding.encoding` attribute.

        Using `Encoding.name` over `Encoding.encoding` is preferred, both for uniformity
        with the [multicodec spec](https://github.com/multiformats/multicodec) and
        to avoid potential confusion between encoding names (strings) and encoding
        objects (instances of `Encoding`).
    &#34;&#34;&#34;
    return self.encoding</code></pre>
</details>
</dd>
<dt id="multiformats.multibase.Encoding.raw_decoder"><code class="name">var <span class="ident">raw_decoder</span> : Callable[[str], bytes]</code></dt>
<dd>
<div class="desc"><p>Returns the raw encoder for this encoding:
given a string without the multibase prefix, it produces the decoded data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_decoder(self) -&gt; RawDecoder:
    &#34;&#34;&#34;
        Returns the raw encoder for this encoding:
        given a string without the multibase prefix, it produces the decoded data.
    &#34;&#34;&#34;
    if self.name not in _decoder_table:
        raise NotImplementedError(f&#34;Decoding using {self.name} is not yet implemented.&#34;)
    return _decoder_table[self.name]</code></pre>
</details>
</dd>
<dt id="multiformats.multibase.Encoding.raw_encoder"><code class="name">var <span class="ident">raw_encoder</span> : Callable[[bytes], str]</code></dt>
<dd>
<div class="desc"><p>Returns the raw encoder for this encoding:
given bytes, it produces the encoded string without the multibase prefix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_encoder(self) -&gt; RawEncoder:
    &#34;&#34;&#34;
        Returns the raw encoder for this encoding:
        given bytes, it produces the encoded string without the multibase prefix.
    &#34;&#34;&#34;
    if self.name not in _encoder_table:
        raise NotImplementedError(f&#34;Encoding using {self.name} is not yet implemented.&#34;)
    return _encoder_table[self.name]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="multiformats.multibase.Encoding.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, data: str) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a multibase string into bytes: it first checks that the multibase
prefix matches the value specified by <code><a title="multiformats.multibase.Encoding.code" href="#multiformats.multibase.Encoding.code">Encoding.code</a></code>, then uses
<code><a title="multiformats.multibase.Encoding.raw_encoder" href="#multiformats.multibase.Encoding.raw_encoder">Encoding.raw_encoder</a></code> on the string without prefix and returns the bytes.</p>
<p>Example usage:</p>
<pre><code class="language-py"></code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self, data: str) -&gt; bytes:
    &#34;&#34;&#34;
        Decodes a multibase string into bytes: it first checks that the multibase
        prefix matches the value specified by `Encoding.code`, then uses
        `Encoding.raw_encoder` on the string without prefix and returns the bytes.

        Example usage:

        ```py
        ```
    &#34;&#34;&#34;
    if data[0] != self.code:
        raise ValueError(f&#34;Expected {repr(self.name)} encoding, &#34;
                         f&#34;found {repr(get(data[0]).name)} encoding instead.&#34;)
    return self.raw_decoder(data[1:])</code></pre>
</details>
</dd>
<dt id="multiformats.multibase.Encoding.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self, data: bytes) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes bytes into a multibase string: it first uses <code><a title="multiformats.multibase.Encoding.raw_encoder" href="#multiformats.multibase.Encoding.raw_encoder">Encoding.raw_encoder</a></code>,
and then prepends the multibase prefix given by <code><a title="multiformats.multibase.Encoding.code" href="#multiformats.multibase.Encoding.code">Encoding.code</a></code> and returns
the resulting multibase string.</p>
<p>Example usage:</p>
<pre><code class="language-py"></code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self, data: bytes) -&gt; str:
    &#34;&#34;&#34;
        Encodes bytes into a multibase string: it first uses `Encoding.raw_encoder`,
        and then prepends the multibase prefix given by `Encoding.code` and returns
        the resulting multibase string.

        Example usage:

        ```py
        ```
    &#34;&#34;&#34;
    return self.code+self.raw_encoder(data)</code></pre>
</details>
</dd>
<dt id="multiformats.multibase.Encoding.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> Mapping[str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a JSON dictionary representation of this <code><a title="multiformats.multibase.Encoding" href="#multiformats.multibase.Encoding">Encoding</a></code> object,
compatible with the one from the multibase.csv table found in the
<a href="https://github.com/multiformats/multibase">multibase spec</a>.</p>
<p>Example usage:</p>
<pre><code class="language-py"></code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; Mapping[str, str]:
    &#34;&#34;&#34;
        Returns a JSON dictionary representation of this `Encoding` object,
        compatible with the one from the multibase.csv table found in the
        [multibase spec](https://github.com/multiformats/multibase).

        Example usage:

        ```py
        ```
    &#34;&#34;&#34;
    code = self.code
    if code not in range(0x20, 0x7F):
        code = hex(ord(code))
    return {
        &#34;encoding&#34;: self.encoding,
        &#34;code&#34;: code,
        &#34;status&#34;: self.status,
        &#34;description&#34;: self.description
    }</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="multiformats.multibase.RawEncoding"><code class="flex name class">
<span>class <span class="ident">RawEncoding</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RawEncoding(ABC):

    @abstractmethod
    def encode(self, b: bytes) -&gt; str:
        ...

    @abstractmethod
    def decode(self, s: str) -&gt; bytes:
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="multiformats.multibase.AlphabeticRawEncoding" href="#multiformats.multibase.AlphabeticRawEncoding">AlphabeticRawEncoding</a></li>
<li><a title="multiformats.multibase.CustomRawEncoding" href="#multiformats.multibase.CustomRawEncoding">CustomRawEncoding</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="multiformats.multibase.RawEncoding.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, s: str) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def decode(self, s: str) -&gt; bytes:
    ...</code></pre>
</details>
</dd>
<dt id="multiformats.multibase.RawEncoding.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self, b: bytes) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def encode(self, b: bytes) -&gt; str:
    ...</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="multiformats" href="index.html">multiformats</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="multiformats.multibase.build_multibase_tables" href="#multiformats.multibase.build_multibase_tables">build_multibase_tables</a></code></li>
<li><code><a title="multiformats.multibase.decode" href="#multiformats.multibase.decode">decode</a></code></li>
<li><code><a title="multiformats.multibase.decoder" href="#multiformats.multibase.decoder">decoder</a></code></li>
<li><code><a title="multiformats.multibase.encode" href="#multiformats.multibase.encode">encode</a></code></li>
<li><code><a title="multiformats.multibase.encoder" href="#multiformats.multibase.encoder">encoder</a></code></li>
<li><code><a title="multiformats.multibase.encoding_of" href="#multiformats.multibase.encoding_of">encoding_of</a></code></li>
<li><code><a title="multiformats.multibase.exists" href="#multiformats.multibase.exists">exists</a></code></li>
<li><code><a title="multiformats.multibase.get" href="#multiformats.multibase.get">get</a></code></li>
<li><code><a title="multiformats.multibase.table" href="#multiformats.multibase.table">table</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="multiformats.multibase.AlphabeticRawEncoding" href="#multiformats.multibase.AlphabeticRawEncoding">AlphabeticRawEncoding</a></code></h4>
<ul class="">
<li><code><a title="multiformats.multibase.AlphabeticRawEncoding.decode" href="#multiformats.multibase.AlphabeticRawEncoding.decode">decode</a></code></li>
<li><code><a title="multiformats.multibase.AlphabeticRawEncoding.encode" href="#multiformats.multibase.AlphabeticRawEncoding.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="multiformats.multibase.CustomRawEncoding" href="#multiformats.multibase.CustomRawEncoding">CustomRawEncoding</a></code></h4>
<ul class="">
<li><code><a title="multiformats.multibase.CustomRawEncoding.decode" href="#multiformats.multibase.CustomRawEncoding.decode">decode</a></code></li>
<li><code><a title="multiformats.multibase.CustomRawEncoding.encode" href="#multiformats.multibase.CustomRawEncoding.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="multiformats.multibase.Encoding" href="#multiformats.multibase.Encoding">Encoding</a></code></h4>
<ul class="two-column">
<li><code><a title="multiformats.multibase.Encoding.code" href="#multiformats.multibase.Encoding.code">code</a></code></li>
<li><code><a title="multiformats.multibase.Encoding.decode" href="#multiformats.multibase.Encoding.decode">decode</a></code></li>
<li><code><a title="multiformats.multibase.Encoding.description" href="#multiformats.multibase.Encoding.description">description</a></code></li>
<li><code><a title="multiformats.multibase.Encoding.encode" href="#multiformats.multibase.Encoding.encode">encode</a></code></li>
<li><code><a title="multiformats.multibase.Encoding.encoding" href="#multiformats.multibase.Encoding.encoding">encoding</a></code></li>
<li><code><a title="multiformats.multibase.Encoding.from_json" href="#multiformats.multibase.Encoding.from_json">from_json</a></code></li>
<li><code><a title="multiformats.multibase.Encoding.name" href="#multiformats.multibase.Encoding.name">name</a></code></li>
<li><code><a title="multiformats.multibase.Encoding.raw_decoder" href="#multiformats.multibase.Encoding.raw_decoder">raw_decoder</a></code></li>
<li><code><a title="multiformats.multibase.Encoding.raw_encoder" href="#multiformats.multibase.Encoding.raw_encoder">raw_encoder</a></code></li>
<li><code><a title="multiformats.multibase.Encoding.status" href="#multiformats.multibase.Encoding.status">status</a></code></li>
<li><code><a title="multiformats.multibase.Encoding.to_json" href="#multiformats.multibase.Encoding.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="multiformats.multibase.RawEncoding" href="#multiformats.multibase.RawEncoding">RawEncoding</a></code></h4>
<ul class="">
<li><code><a title="multiformats.multibase.RawEncoding.decode" href="#multiformats.multibase.RawEncoding.decode">decode</a></code></li>
<li><code><a title="multiformats.multibase.RawEncoding.encode" href="#multiformats.multibase.RawEncoding.encode">encode</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>